<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sailpoint PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<sailpoint>
  <Rule created="1651241695534" id="c0a8010480751c5d818075acb92e0117" language="beanshell" modified="1655896193808" name="No Correlator" type="Correlation"/>
  <Rule created="1651241695679" id="c0a8010480751c5d818075acb9bf0118" language="beanshell" modified="1655896193992" name="Clear CustomGlobal">
    <Source>
      
        import sailpoint.object.CustomGlobal;

        List results = new ArrayList();
        results.add("CustomGlobal BEFORE clear had ["+
                    CustomGlobal.size() + "] keys.");
        CustomGlobal.clear();
        results.add("CustomGlobal AFTER clear has [" +
                   CustomGlobal.size()+"] keys.");

        return results;
      
    </Source>
  </Rule>
  <Rule created="1651241696417" id="c0a8010480751c5d818075acbc9f013f" language="beanshell" modified="1662117612103" name="IdentityNowSAML" type="SAMLCorrelation">
    <Signature>
      <Inputs>
        <Argument name="log">
          <Description>
                    Logger to take care of logging.
                </Description>
        </Argument>
        <Argument name="context">
          <Description>
                    SailPointContext
                </Description>
        </Argument>
        <Argument name="assertionAttributes">
          <Description>
                    Map of attributes taken from the SAML assertion
                </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="ident">
          <Description>
                    Matching identity based on the nameId taken from assertionAttributes
                </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>
        
            // Imports
            import sailpoint.object.Identity;

            // Making a BIG assumption here that the nameid-format is unspecified/persitent

            // Get the nameId from the assertionAttributes
            String nameId = (String)assertionAttributes.get("nameId");

            Identity ident;

            if(nameId != null) {
                // Lookup the identity based on nameId
                ident = context.getObject(Identity.class, nameId);
            }

            return ident;

        
    </Source>
  </Rule>
  <Rule created="1651241697053" id="c0a8010480751c5d818075acbf1c0167" language="beanshell" modified="1662117612416" name="Workflow Library">
    <Source>
    
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.QueryOptions;
      import sailpoint.tools.GeneralException;
      import sailpoint.tools.Util;
      import sailpoint.api.ObjectUtil;

      boolean otob(Object o) { return Util.otob(o); }
      boolean isTrue(Object o) {otob(o); } 
      boolean isFalse(Object o) {!otob(o); }
      boolean isNull(Object o) {o == null; } 
      int size(Collection o) { return Util.size(o); }
      String toString(Object o) {(o == null) ? "*null*" : o.toString(); }
      void println(Object o) {System.out.println(o); }
      void print(String str) { System.out.print(str); }
      void printval(String n, Object o) {println(n + " = " + toString(o)); }


      public List csvToList(String csv) {
        return Util.csvToList(csv);
      }

      /** 
       * resolve displayName by doing a projection query.
       */ 
      public String resolveDisplayName(String identityName) {
          String displayName = getIdentityProperty(identityName, "displayName"); 
          if ( displayName == null ) {
              displayName = identityName;
          }
          return displayName;
      }
      
      /** 
       * If the identityDisplayName is null resolve it by doing
       * a projection query.
       */ 
      public String resolveDisplayName(String identityName, String currentDisplayName) {
          // allow it to be passed in to avoid the query
          String displayName = null;
          if ( currentDisplayName != void ) {
              displayName = currentDisplayName;
          }
          if ( displayName == null ) {
              displayName = resolveDisplayName(identityName);
          }
          return displayName;
      }

      /**
       * Given an Identity's name or workgroup, return the email address.
       * First, we try to get the identities email address and if that doesn't exist
       * assume it is a workgroup and get the email addresses accordingly.
       */
      public String getEmail(String name) {
          // Try to get the email address from the identity
          String email = getIdentityProperty(name, "email");

          // If there is no identity email defined try to get workgroup email.
          if (null == email) {
              Identity identity = context.getObject(Identity.class, name);
              if (identity != null) {
                  email = Util.listToCsv(ObjectUtil.getEffectiveEmails(context, identity));
              }
          }

          return email;
      }

      /**
       * Given an Identity's name and a ProvisioningPlan, return the email address.
       * This can be used for user notifications when a request to create an
       * identity was rejected.  In this case there will not be an identity in
       * the database, so we will try to extract the email address from the plan.
       */
      public String getUserEmail(String name, ProvisioningPlan plan) {
          String email = getEmail(name);

          if (null == email) {
              email = getIIQCreateRequestValue(plan, "email");
          }

          return email;
      }

      /**
       * Given an Identity's name, return the manager's email address.
       */
      public String getManagersEmail(String name) {
          return getIdentityProperty(name, "manager.email"); 
      }

      /**
       * Given an Identity's name, return the manager's email address.
       * This can be used for user notifications when a request to create an
       * identity was rejected.  In this case there will not be an identity in
       * the database, so we will try to extract the manager from the plan to
       * lookup the email address.
       */
      public String getManagersEmail(String name, ProvisioningPlan plan) {
          String email = getManagersEmail(name);

          if (null == email) {
              String manager = getIIQCreateRequestValue(plan, "manager");
              if (null != manager) {
                  Identity identity = context.getObject(Identity.class, manager);
                  if (null != identity) {
                      email = identity.getEmail();
                  }
              }
          }

          return email;
      }

      /**
       * Return the value for the requested attribute from the ProvisioningPlan
       * if this is an identity creation request.
       */
      private String getIIQCreateRequestValue(ProvisioningPlan plan, String attr) {
          String value = null;

          if (null != plan) {
              AccountRequest acctReq = plan.getIIQAccountRequest();
              if ((null != acctReq) &amp;&amp;
                  AccountRequest.Operation.Create.equals(acctReq.getOperation())) {
                  AttributeRequest attrReq = acctReq.getAttributeRequest(attr);
                  if (null != attrReq) {
                      value = (String) attrReq.getValue();
                  }
              }
          }

          return value;
      }

      /** 
       * Return a single string property value from an identity.
       */
      public String getIdentityProperty(String identity, String property) {
          QueryOptions ops = new QueryOptions();
          Filter nameFilter = Filter.eq("name", identity);
          ops.add(new Filter[]{nameFilter});

          String val = null; 
          Iterator it = context.search(Identity.class, ops, property);
          while ( it.hasNext() ) {
              Object[] row = (Object[])it.next();
              val = (String)row[0];
              if ( it.hasNext() ) {
                  // shouldn't happen but guard
                  throw new GeneralException("More then one ["+property+"] value returned for ["+identity+"]");
              }
          } 
          return val;
      }

      /**
       * Return the value of a system configuration property.
       * The value is always returned as a string.
       */
      public String getConfiguration(String name) {
          return context.getConfiguration().getString(name);
      }

    
  </Source>
  </Rule>
  <Rule created="1651241697192" id="c0a8010480751c5d818075acbfa80168" language="beanshell" modified="1662117612605" name="Approval Library">
    <Source>
    

    import sailpoint.api.ManagedAttributer;
    import sailpoint.object.Application;
    import sailpoint.object.ApprovalSet;
    import sailpoint.object.ApprovalItem;
    import sailpoint.object.AttributeDefinition;
    import sailpoint.object.Attributes;
    import sailpoint.object.Bundle;
    import sailpoint.object.Identity;
    import sailpoint.object.ManagedAttribute;
    import sailpoint.object.ProvisioningPlan;
    import sailpoint.object.ProvisioningPlan.AccountRequest;
    import sailpoint.object.ProvisioningPlan.AttributeRequest;
    import sailpoint.object.ProvisioningPlan.PermissionRequest;
    import sailpoint.object.ProvisioningPlan.GenericRequest;
    import sailpoint.object.ProvisioningProject;
    import sailpoint.object.Scope;
    import sailpoint.object.WorkItem;
    import sailpoint.object.Workflow;
    import sailpoint.object.Workflow.Approval;
    import sailpoint.tools.Util;
    import sailpoint.tools.xml.XMLObjectFactory;
    
    /** 
    * Take a list of AttributeRequests and return a List of Attributes
    * to store on the approval item so that we can get at the attributes of
    * each attribute request in case we need information about that attribute request
    */
    public Attributes getAttributeRequestArguments(List attributeRequests) {
      Attributes attributes = new Attributes();
      for(AttributeRequest attr : attributeRequests) {
        String key = attr.getName()+":"+attr.getValue();
        Attributes arguments = attr.getArguments();
        attributes.put(key, arguments);
      }
      return attributes;
    }

    /**
     * Turn a list of AttributeRequests into simple
     * name = 'value' format. Represent this as a list
     * so we can display it neatly in the ui tier and
     * still not mess with dn strings.
     *
     * A general utility method used both by rules and workflow
     * scripts.  
     */
    public List flattenAttributeRequests(List attributeRequests) {
        List flat = new ArrayList();
        flattenAttributeRequests(attributeRequests, flat);
        return flat;
    }
    
    /**
    *  Bug 15833, ensure requester comments make it into manual actions
    */
    public String getRequesterComments(List requests) {
        String comment = "";
        if(requests != null) {
            for(GenericRequest request : requests) {
                String innerComment = request.getComments();
                if ( Util.getString(innerComment) != null ) {
                    comment += innerComment;
                }
            }
        }
        return comment;
    }
        
    public void flattenAttributeRequests(List attributeRequests, List flat) {
        if ( Util.size(attributeRequests) > 0 ) {
            for (AttributeRequest attr : attributeRequests ) {
                if( !attr.getName().equals(ProvisioningPlan.ATT_IIQ_PASSWORD) &amp;&amp;
                    !attr.getBoolean(ProvisioningPlan.ARG_SECRET) &amp;&amp;
                    !attr.getName().equals(Identity.PRF_USE_BY_DATE)) {
                    if (attr.getDisplayValue() == null) {
                        String displayName = attr.getName();
                        List val = Util.asList(attr.getValue());
                        if ( val != null ) {
                            if ( attr.getName().equals("manager") ) { 
                                String managerName = null;
                                if ( Util.size(val) == 1 ) {
                                    // For manager convert the name into a displayName so it looks 
                                    // reasonable in the ui
                                    managerName = (String)val.get(0);
                                    if ( manager != null ) {
                                        String displayName = getIdentityProperty(managerName, "displayName");
                                        if ( displayName != null ) {
                                            val = Util.csvToList(displayName);
                                        }
                                    }
                                }
                            }
                            
                            String type = (String)attr.get(ProvisioningPlan.ARG_TYPE);
                            if (type!=null &amp;&amp; type.equals(ProvisioningPlan.ARG_TYPE_DATE)) {
                              Object obj = val.get(0);
                              
                              Date date = null;
                              
                              if(obj instanceof java.util.Date) {
                                date = obj;
                              } else {
                                date = new Date((Long)obj);
                              }
                              val = new ArrayList();                         
                              val.add(Util.dateToString(date, "M/d/y"));
                            } else if (AttributeDefinition.TYPE_SCOPE.equals(type)) {
                              val = getScopeNames(val);  
                            }
                            
                        }
                        if ( Util.size(val) > 0 ) 
                            flat.add(displayName+ " = '"+Util.listToCsv(val)+"'");
                    } else {
                        flat.add(attr.getDisplayValue());
                    }
                }
            }
        }
    }
    
    /*
     * Given a list of scope ids it will return a list of 
     * scope names.
     *
     */
    public List getScopeNames(List val) {
        
        if (val == null) {
            return null;
        }

        List scopeNames = new ArrayList();
        for (int i=0; i&lt;val.size(); ++i) {
            scopeNames.add(fetchScopeName((String) val.get(i)));
        }
        
        return scopeNames;
    }

    /**
     * Fetches a scope name from scope id
     *
     */    
    private String fetchScopeName(String id) {
        
        Scope scope =  context.getObjectById(Scope.class, id);
        
        if (scope == null) {
            return null;
        }
        
        return scope.getDisplayableName();
    }

    /**
     * Convert a List&lt;PermissionRequests> into a List&lt;String>
     * with each string formatted as "target='right,right,right'"
     * This is similar to flattenAttributeRequests above but 
     * kept distinct in case we need to change the rendering of permissions.
     * Currently it's ambiguous whether this is an attribute or a permission
     */
    public void flattenPermissionRequests(List permRequests, List flat) {

        if (permRequests != null) {
            for (PermissionRequest perm : permRequests ) {

              // we dont' have display names for targets, do we?
              flat.add(perm.getTarget() + " = '" + perm.getRights() + "'");
            }
        }
    }

    /**
     * Convert a Map&lt;String,ApprovalSet> into Approval objects. 
     * One Approval object for each of the keys in the map.
     *
     * Used only by rules that calculate approval structures such
     * as LCM Build Owner Approvals.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List buildApprovalsFromMap(Map ownerToSet, String identityName, String launcher) {
        List approvals = new ArrayList();
        if ( ownerToSet == null ) 
            return null;

        Iterator keys = null;
        Set keySet = ownerToSet.keySet();
        if ( keySet != null )  
            keys = keySet.iterator();

        if ( keys != null ) {
            while ( keys.hasNext() ) {
                String key = (String)keys.next();
                if ( key == null ) continue;
                ApprovalSet set = ownerToSet.get(key);
                if ( set != null ) {
                    if ( log.isDebugEnabled() ) {
                        log.debug("Owner["+key+"] " + set.toXml());
                    }
                    // djs: check here to make sure this isn't an auto-approved 
                    // item because the approver is the launcher
                    if ( !sailpoint.workflow.IdentityLibrary.isElectronicSignatureEnabled(wfcontext) &amp;&amp; 
                         key.compareTo(launcher) == 0 &amp;&amp; 
                         set.isAllApproved() ) {
                        // self approved continue;
                        continue;
                    } else {
                        Approval newApproval = new Approval();
                        newApproval.setOwner("\"" + key + "\"");  // quote the owner in case the user name has a comma
                        newApproval.setApprovalSet(set);
                        newApproval.addArg(Workflow.ARG_WORK_ITEM_TARGET_CLASS, "sailpoint.object.Identity");
                        newApproval.addArg(Workflow.ARG_WORK_ITEM_TARGET_NAME, identityName);
                        approvals.add(newApproval);
                    } 
                }
            }
        }
        if ( log.isDebugEnabled() ) {
            if ( approvals != null )
                log.debug("Approvals: " + XMLObjectFactory.getInstance().toXml(approvals));
            else
                log.debug("Approvals EMPTY.");
        }
        return approvals;
    }

    /**
     * Build a Map&lt;String,ApprovalSet> each key representing a unique owner.
     * Use a Map here to allow us to easily merge any items for the same owner.
     *
     * Used by rules to build approval structures, normally followed by
     * a call to buildApprovalsFromMap.
     * 
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public Map buildOwnerMap(String scheme, ApprovalSet approvalSet, 
                             ProvisioningPlan plan, String fallbackApprover, 
                             String identity, boolean autoApprove) {

        // djs: use a LinkedHashMap here to perserve the order of the
        // approvers in the list.  This is important for manager transfer
        // approvals.
        Map ownerToSet = new LinkedHashMap();
        List items = approvalSet.getItems();
        for ( ApprovalItem item : items ) {
            List approvers = getApproverNames(scheme, item, plan, identity);
            if ( approvers != null &amp;&amp; approvers.size() == 0 &amp;&amp; fallbackApprover != null ) {
                if ( log.isDebugEnabled() ) {
                    log.debug("Approver could not be resolved using fallbackApprover '"+fallbackApprover+"'.");
                }
                approvers.add(fallbackApprover);
            }
            //
            // Build an approval set or add an ApprovalItem 
            // to an existing set
            //
            if ( Util.size(approvers) > 0 ) {
                for ( String approver : approvers ) {
                    ApprovalSet set = (ApprovalSet)ownerToSet.get(approver);
                    if ( set == null ) {
                        set = new ApprovalSet();
                    }

                    // Make a copy of the item here so they are independent of the the
                    // cart's item.  
                    ApprovalItem itemCopy = XMLObjectFactory.getInstance().clone(item, context);
                    set.add(itemCopy);
                    ownerToSet.put(approver, set);
                    if ( autoApprove ) {
                        // djs: when we come across the launcher who is also the approver
                        // auto approve the item, this will allow us to audit/report on
                        // the request but not force an approval.  We won't create an 
                        // Approval object if all of the items are acccepted
                        if ( approver.equals(launcher) ) {
                            itemCopy.setState(WorkItem.State.Finished);
                            if ( log.isDebugEnabled() ) {
                                log.debug("Launcher was also approver and was removed.");
                            }
                            // If there is just one approver AND we are marking this 
                            // Auto-Approved also mark the master approvalSets item 
                            // finished
                            if ( approvers.size() == 1 ) {
                                item.setState(WorkItem.State.Finished);
                            }
                        }
                    }
                }
                //
                // Update the "cart" representation
                //
                // set the item's owner so we have an update
                // version in the "registry"
                // Should we store a csv Multiple approvers ?
                item.setOwner(approvers.get(0));
            }
        }
        if ( log.isDebugEnabled() ) {
            if ( ownerToSet != null )
                log.debug("OwnerSetMap: " + XMLObjectFactory.getInstance().toXml(ownerToSet));
            else
                log.debug("OwnerSetMap EMPTY.");
        }
        return ownerToSet;
    }

    /**
     * Return a list of names that represent the names of the Identities that should
     * approve the item.  We need the Plan during manager transfers when we need to figure
     * out what the new value is for the manager attribute.
     *
     * Only time the returned list is null is when we have "none"
     * approval scheme.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List getApproverNames(String scheme, ApprovalItem item, ProvisioningPlan plan, String identity) {
        return getApproverNames(scheme, item, plan, identity, null);
    }

    /**
     * Return a list of names that represent the names of the Identities that should
     * approve the item.  We need the Plan during manager transfers when we need to figure
     * out what the new value is for the manager attribute.
     *
     * Only time the returned list is null is when we have "none"
     * approval scheme.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    public List getApproverNames(String scheme, ApprovalItem item, ProvisioningPlan plan,
                                 String identity, String securityOfficerName) { 

        List owners = new ArrayList();
        String schemeToUse = scheme;
        if ( schemeToUse == null ) {
            schemeToUse = "manager";
            log.warn("Approval Scheme was not defined defaulting to manager.");
        }
        List schemes = Util.csvToList(schemeToUse);

        // None will short-circuit and cause no approvals.
        if ( schemes.contains("none") ) {
            return null;
        } 

        if ( ( schemes.contains("manager") ) || ( schemes.contains("newManager") ) ) {
            List managers = getManagers(schemes, plan, identity);
            if ( null != managers ) { 
                owners.addAll(managers);
            } 
        }

        if ( schemes.contains("owner") ) {
            String app = item.getApplication(); 
            String op = item.getOperation();
            if ( ProvisioningPlan.APP_IIQ.compareTo(app) == 0 ) { 
                if ( ( ProvisioningPlan.Operation.Add.toString().equals(op) ) || 
                     ( ProvisioningPlan.Operation.Remove.toString().equals(op) ) ) {
                    // this is a role requst, entitlement request or identity update
                    if ( ( ProvisioningPlan.ATT_IIQ_DETECTED_ROLES.equals(item.getName()) ) ||
                         ( ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES.equals(item.getName()) ) ) {
                        String owner = resolveRoleOwner(item);
                        if ( owner != null ) owners.add(owner);
                    } 
                }
           } else {
               String owner = resolveAppRequestOwner(item);
               if ( owner != null ) 
                  owners.add(owner);
           }
        }

        if ( schemes.contains("securityOfficer") ) {
            if (null == securityOfficerName) {
                log.warn("Security officer approval is configured but securityOfficerName is not defined.");
            }
            else {
                // Only use the security officer if it is a real identity.
                Identity officer = context.getObjectByName(Identity.class, securityOfficerName);
                if (null == officer) {
                    log.warn("Could not find securityOfficer: " + securityOfficerName);
                }
                else {
                    owners.add(securityOfficerName);
                }
            }
        }

        return owners;
    }

    /**
     * Helper for getApproverNames.
     * From the item figure out the owner that should be assigned
     * to this application request.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveAppRequestOwner(ApprovalItem item) {
        String approverName = null;

        String appName = item.getApplication();
        if ( appName == null ) return null;

        Application application = context.getObjectByName(Application.class, appName);
        if ( application == null ) 
            throw new Exception("Couldn't find application ["+appName+"]");

        Identity owner = application.getOwner();
        if ( owner != null ) {
            approverName = owner.getName();
        } else {
            // unable to find owner for application foo...
            log.debug("Unable to find owner for application ["+appName+"]");
        }

        // Check the attributeName and value and check to see if we are dealing with 
        // a ManagedAttribute 
        String attrName = item.getName();
        List vals = item.getValueList();
        if ( ( attrName != null ) &amp;&amp; ( Util.size(vals) > 0 ) ) {
            // there should just be one value in each record... 
            // log something
            String val = (String)vals.get(0);
            String maOwner = getManagedAttributeOwner(application, attrName, val);
            if ( maOwner == null) {
                log.debug("Managed Attribute owner not found.. falling back to app owner.");
            } else {
                approverName = maOwner;
            }
        }
        return approverName;
    }

    /**
     * Helper for resolveAppRequestOwner.
     * Use the ManagedAttributer to find the managed attribute and get the
     * owner from the ManagedAttribute.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String getManagedAttributeOwner(Application app, String name, String value ) {
        String owner = null;
        ManagedAttribute ma = ManagedAttributer.get(context, app.getId(), name, value);
        if ( ma != null ) {
            Identity maOwner = ma.getOwner();
            if ( maOwner != null ) 
                owner = maOwner.getName();
        }
        return owner;
    }

    /**
     * Helper for getApproverNames.
     * If its a role request look up the role by name and get the owner
     * from the Role object.  
     *
     * TODO: should I walk up the hierarchy here if ther isn't 
     * one on the Bundle?
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveRoleOwner(ApprovalItem item) {
        String approverName = null;
        List values = item.getValueList();
        if ( Util.size(values) > 0 ) {
            if ( Util.size(values) != 1 ) 
                throw new Exception("More then one value found in an approval item");

            String roleName = (String)values.get(0);
            if ( roleName != null ) {
                Bundle b = context.getObjectByName(Bundle.class, roleName);
                if ( b != null ) {
                    Identity id = b.getOwner();
                    if ( id != null ) {
                        approverName = id.getName();
                    }
                }
            }
        }
        return approverName;
    }

    /**
     * Helper for getApproverNames.
     * Get the value for manager or other by resolving the identity
     * and computing the manager, or validating the value
     * in the approvalScheme variable;
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private List getManagers(List schemes, ProvisioningPlan plan, String identity) {
        //  
        //  During Identity Creates the Identity object does not exist
        //    In this case we have to look at the plan and see if one is assigned
        //    if not assigned default to the fallbackApprover
        // 
        //  During Updates there could be one or two managers in play
        //    1) Newly assigned manager (which is still in the plan)
        //    2) Currently assigned manager ( assigned to the identity )
        //    
        List approverNames = new ArrayList();

        String currentManager = null;
        // Use the identities manager to resolve the approval
        Identity identityObject = context.getObject(Identity.class, identity);
        if ( identityObject != null ) {
            Identity manager = identityObject.getManager();
            if ( manager != null ) {
                currentManager = manager.getName();
            } else {
                log.debug("Manager not found for ["+identityObject.getName()+"] while computing approval");
            }
        }

        String planManager = resolveManagerFromPlan(plan);
        if ( ( currentManager == null ) &amp;&amp; ( planManager != null ) ) {
            // likely Identity Create case
            approverNames.add(planManager);
        } else
            if ( ( currentManager != null ) &amp;&amp; ( planManager == null ) ) {
                // normal case
                approverNames.add(currentManager);
            } else
                if ( ( currentManager != null ) &amp;&amp; ( planManager != null ) ) {
                    // Manager Transfer
                    if ( schemes.contains("manager") ){
                        approverNames.add(currentManager);
                    }
                    if ( schemes.contains("newManager") ){
                        approverNames.add(planManager);
                    } 
                }
        return ( approverNames.size() > 0 ) ? approverNames : null;
    }

    /**
     * Helper for getManagers.
     * Dig into the plan and find the manager attribute for the IIQ
     * app if present. This is used during manager transfers
     * where we need to know the new manager so they can be 
     * part of the approval process.
     *
     * NOTE:
     * As of 6.2 this rule has been deprecated and replaced with
     * IdentityLibrary.buildXYZApproval methods.  Most of the
     * logic here has been moved to 
     * sailpoint.workflow.IdentityApprovalGenerator.
     */
    private String resolveManagerFromPlan(ProvisioningPlan plan )  {
        String managerName = null;
        if ( plan != null ) {
            AccountRequest iiq = plan.getAccountRequest(ProvisioningPlan.APP_IIQ);
            if ( iiq != null ) {
                AttributeRequest manager = iiq.getAttributeRequest("manager");
                if ( manager != null ) {
                    Object obj = manager.getValue();
                    if ( obj != null ) {
                        managerName = Util.getString(obj.toString());
                    }
                }
            }
        }
        return managerName;
    }

    
  </Source>
  </Rule>
  <Rule created="1651241697442" id="c0a8010480751c5d818075acc0a20169" language="beanshell" modified="1662117612813" name="Build Manual Action Approvals">
    <ReferencedRules>
      <Reference class="sailpoint.object.Rule" id="c0a8010480751c5d818075acbfa80168" name="Approval Library"/>
    </ReferencedRules>
    <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ApprovalItem;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.object.ProvisioningPlan.AccountRequest;
       import sailpoint.service.ProvisioningTransactionService;
       import sailpoint.service.ProvisioningTransactionService.TransactionDetails;
       import sailpoint.workflow.IdentityLibrary;

       //
       // Attributes needed in the rule context: 
       //
       // project - Provisioning Project
       //
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //

       List approvals = null;
       ProvisioningPlan unmanaged = project.getUnmanagedPlan();
       if ( unmanaged != null ) {
           // 
           // Build an ApprovalSet from each of the things in the plan 
           // 
           Identity id = context.getObject(Identity.class, identityName);
           ApprovalSet set = new ApprovalSet();
           for ( AccountRequest acctReq : unmanaged.getAccountRequests() ) {
               ProvisioningTransactionService transService = new ProvisioningTransactionService(context);

               AccountRequest account = new AccountRequest(acctReq.toMap());
               if ( AccountRequest.Operation.Create.equals(account.getOperation()) ) {
                   ApprovalItem item = new ApprovalItem();
                   // need to deal with this 
                   item.setApplication(account.getApplication());
                   item.setInstance(account.getInstance());
                   item.setNativeIdentity(account.getNativeIdentity());
                   AccountRequest.Operation op = account.getOperation();
                   if (op == null) {
                       // shouldn't be here but assume modify
                       op = AccountRequest.Operation.Modify;
                   }
                   item.setOperation(op.toString());
                   
                   //MEH 15833, get those comments transferred to the new approval item!
                   String requesterComments = null;
                   String attrComments = getRequesterComments(account.getAttributeRequests());
                   String permComments = getRequesterComments(account.getPermissionRequests());
                   
                   //only one of these should be set... ideally
                   if(attrComments.length() > 0) {
                      requesterComments = attrComments;
                   }
                   
                   if(permComments.length() > 0) {
                      requesterComments = permComments;
                   }

                   if(requesterComments == null) {
                      if(account.getComments() != null) {
                         requesterComments = account.getComments();
                      }
                   }

                   item.setRequesterComments(requesterComments);

                   List reqs = new ArrayList();
                   
                   flattenAttributeRequests(account.getAttributeRequests(), reqs);
                   flattenPermissionRequests(account.getPermissionRequests(), reqs);

                   item.setValue(reqs);
                   set.add(item);
               } else {
                   // The default ApprovalSet builder creates an ApprovalItem for
                   // every attribute/permission request
                   IdentityLibrary.addApprovalItems(id, account, set);
               }

               TransactionDetails details = new TransactionDetails();
               details.setIdentityName(identityName);
               details.setProject(project);
               details.setRequest(account);
               details.setPartitionedPlan(unmanaged);
               details.setManual(true);

               if (project.getMasterPlan() != null) {
                   details.setSource(project.getMasterPlan().getSource());
               }

               transService.logTransaction(details);
           }
           // 
           // Build a map of owner to ApprovalSet from each of the items
           // in the unmanaged plan 
           // 
           // Default to the owner scheme, but we might need an option 
           // 
           Map ownerMap = buildOwnerMap("owner", set, unmanaged, fallbackApprover, identityName, false);
           if ( ownerMap != null ) {
               approvals = buildApprovalsFromMap(ownerMap, identityName, launcher);
           }
       }
       return approvals;
    
  </Source>
  </Rule>
  <Rule created="1651241698345" id="c0a8010480751c5d818075acc429017b" language="beanshell" modified="1663747185084" name="LCM Workflow Library">
    <Source>
    
      import sailpoint.api.Provisioner;
      import sailpoint.api.SailPointFactory;
      import sailpoint.api.SailPointContext;
      import sailpoint.object.ApprovalSet;
      import sailpoint.object.ApprovalItem;
      import sailpoint.object.AuditEvent;
      import sailpoint.object.Comment;
      import sailpoint.object.Field;
      import sailpoint.object.Form;
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.ProvisioningProject;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.SignOffHistory;
      import sailpoint.object.Source;
      import sailpoint.object.Workflow;
      import sailpoint.object.Workflow.Approval;
      import sailpoint.object.WorkItem;
      import sailpoint.object.WorkItem.OwnerHistory;
      import sailpoint.server.Auditor;
      import sailpoint.tools.Util;
      import sailpoint.workflow.IdentityLibrary;
      import sailpoint.workflow.WorkflowContext;

      /**
       * Build an event per forward so there is a record 
       * that the owner changed from the original 
       * owner.
       */
      public void auditWorkItemOwnerHistory(WorkItem item) {
          List ownerHistories = item.getOwnerHistory();
          if ( Util.size(ownerHistories) > 0 ) {
              String action = "Forward";
              if ( Auditor.isEnabled(action) ) {
                  for ( OwnerHistory history : ownerHistories ) {
                      AuditEvent event = new AuditEvent();
                      event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                      event.setAction(action);
                      event.setTarget(item.getTargetName());
                      event.setAttribute("workitem", item.getName());
                      String oldOwner = history.getOldOwner();
                      if ( oldOwner != null ) 
                          event.setAttribute("oldOwner", oldOwner);
                      String source = history.getEffectiveSource();
                      event.setSource(source);
                      String comment = history.getComment();
                      if ( comment != null ) 
                          event.setAttribute("comment", comment);
                      String newOwner = history.getNewOwner();
                      if ( newOwner != null ) 
                          event.setAttribute("newOwner", newOwner);

                      // djs: for now set this in both places to avoid needing
                      // to upgrade.  Once we have ui support for "interface"
                      // we can remove the map version
                      event.setAttribute("interface", Source.LCM.toString());
                      event.setInterface(Source.LCM.toString());

                      Auditor.log(event);
                  }
              }
          }
      }

      /**
       * Build a single "comment" event for all of the comments
       * that were entered during a workitems lifecycle.
       */
      public void auditWorkItemComments(WorkItem item) {
          List comments = item.getComments();
          if ( Util.size(comments) > 0 ) {
              String action = "Comment";
              if ( Auditor.isEnabled(action) ) {
                  AuditEvent event = new AuditEvent();
                  event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                  event.setAction(action);
                  event.setTarget(item.getTargetName());
                  event.setAttribute("workitem", item.getName());

                  List commentStrings = new ArrayList();
                  for ( Comment comment : comments ) {
                      commentStrings.add(comment.toString());
                  }
                  event.setAttribute("comments", commentStrings);
                  // djs: for now set this in both places to avoid needing
                  // to upgrade.  Once we have ui support for "interface"
                  // we can remove the map version
                  event.setAttribute("interface", Source.LCM.toString());
                  event.setInterface(Source.LCM.toString());
                  Auditor.log(event);
              }
          }
      }

      /**
       * Determine the name to use as the "source" of an LCM work item
       * completion audit.  This should be the name of the identity that
       * closed the item.  This will be different than the item owner if the
       * owner is a work group.
       */
     public String getAuditSource(WorkItem item) {

         String actor = context.getUserName();
         Identity ident = context.getObjectByName(Identity.class, actor);
         if (ident != null)
             actor = ident.getDisplayName();
         else {
             // must be in the background with a pseudo system name
             // fall back to item owner
             ident = item.getOwner();
             if (ident != null)
                 actor = ident.getDisplayName();
             else 
                 actor = launcher;
         }

         return actor;
     }

      public void auditDecisions(WorkItem item) {
          if ( item == null )  return; 

          // there is only one Signoff, duplicated for each approval item
          SignOffHistory signoff = null;
          List signoffs = item.getSignOffs();
          if (signoffs != null &amp;&amp; signoffs.size() > 0)
              signoff = (SignOffHistory)signoffs.get(0);

          ApprovalSet approvalSet = (ApprovalSet)item.get("approvalSet");
          if ( ( approvalSet != null ) &amp;&amp; ( !approvalSet.isEmpty() ) ) {
              for ( ApprovalItem it : approvalSet.getItems() ) {

                  /** Assimilate the form field changes back into the attribute requests before
                  * creating the audit event so that the correct data is stored in the audit event. **/
                  List attrs = it.getIIQAttributes();
                  Form form = (Form)item.get("workItemForm");
                  if(attrs!=null &amp;&amp; form!=null) {
                    for(AttributeRequest attr : attrs) {
                      
                      Field field = form.getField(it.getApplication()+":"+attr.getName());
                      if(field!=null) {
                        attr.setValue(field.getValue());
                      }
                    }
                    it.setValue(flattenAttributeRequests(attrs));                 
                  }
                                    
                  AuditEvent event = new AuditEvent();
                  event.setAction(AuditEvent.ActionApproveLineItem);
                  event.setSource(getAuditSource(item));
                  event.setTarget(identityName);

                  event.setApplication(it.getApplication());
                  event.setAccountName(it.getNativeIdentity());
                  event.setInstance(it.getInstance());
                  event.setAttributeName(it.getName());
                  event.setAttributeValue(it.getCsv());                  
                  
                  // electronic signature
                  if (signoff != null) {
                     String meaning = signoff.getText();
                     if (meaning != null) {
                         event.setAttribute("esignatureSigner", 
                                            signoff.getSignerDisplayableName());
                         event.setAttribute("esignatureText", meaning);
                         // what else, date?
                     }
                 }

                  Date start = it.getStartDate();
                  if ( start != null ) 
                      event.setAttribute("startDate", start);
                  Date end = it.getEndDate();
                  if ( end != null ) 
                      event.setAttribute("endDate", end);

                  event.setAttribute("currentStep", wfcontext.getStep().getName());

                  // group them by a generatedId
                  event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());
                  String interfaceName = wfcontext.getString("interface");
                  if ( interfaceName == null)
                      interfaceName = Source.LCM.toString();

                  // djs: for now set this in both places to avoid needing
                  // to upgrade.  Once we have ui support for "interface"
                  // we can remove the map version
                  event.setAttribute("interface", interfaceName);
                  event.setInterface(interfaceName);

                  event.setAttribute("operation", it.getOperation());
                  event.setAttribute("requester", launcher);

                  List comments = it.getComments();
                  if ( Util.size(comments) > 0 ) {
                      event.setAttribute("completionComments", comments);
                  }

                  String requesterComments = it.getRequesterComments();
                  if ( Util.getString(requesterComments) != null )
                      event.setAttribute("requesterComments", requesterComments);

                  String taskResultId = wfcontext.getString(Workflow.VAR_TASK_RESULT);
                  if ( taskResultId != null ) {
                      event.setAttribute(Workflow.VAR_TASK_RESULT, taskResultId);
                  }

                  if ( !it.isApproved() ) {
                      event.setAction(AuditEvent.ActionRejectLineItem);
                  }

                  if ( Auditor.isEnabled(event.getAction()) ) {
                      Auditor.log(event);
                      wfcontext.getSailPointContext().commitTransaction();
                  }
              }
          }
      }

      public void auditManualAction(WorkItem item) {
          if ( Auditor.isEnabled(AuditEvent.ManualChange) ) {
              ApprovalSet set = (ApprovalSet)item.get("approvalSet");
              if ( set != null ) {
                  List items = set.getItems();
                  if ( Util.size(items) > 0 ) {
                      int num = 0 ;
                      for ( ApprovalItem it : items  ) { 
                          num++;
                          AuditEvent event = IdentityLibrary.buildBaseEvent(wfcontext, it);
                          event.setSource(getAuditSource(item));
                          event.setAction(AuditEvent.ManualChange);
                          event.setAttribute("requester", wfcontext.getString("launcher"));
                          event.setAttribute("op", it.getOperation());
                          List comments = it.getComments();
                          if ( Util.size(comments) > 0 ) {
                              event.setAttribute("completionComments", comments);
                          }
                          Auditor.log(event);
                      }
                      if ( num > 0 ) 
                          wfcontext.getSailPointContext().commitTransaction();
                  }
              } else {
                  throw new GeneralException("ApprovalSet not found in the afterscript.");
              }
          } 
      }

      /**
       * After an approval has been made apply the changes from the workitem back into the
       * cart. (approvalSet)
       */
      public void assimilateWorkItemApprovalSet(WorkflowContext wfcontext, WorkItem item, ApprovalSet approvalSet) {
         if (item == null) {
              // must not be a leaf approval...
              return;
          }
          // Assimilate all of the approvalItem changes into our gloval
          // approval set
          // 
          // Also audit the comments and forwarding thats happend
          ApprovalSet set = (ApprovalSet)item.get("approvalSet");
          if ( set != null ) {
              // Global completion comments will apply to each of the items
              // If there are completion comments append them
              // to any other completion comments, but typically its 
              // one or the other
              String completionComments = item.getCompletionComments();
              String ownerName = null;
              Identity id = item.getOwner();
              if ( id != null ) {
                  ownerName = id.getName();
              }
              approvalSet.assimilate(set, ownerName, completionComments, true);
          } else {
              throw new GeneralException("ApprovalSet not found in the afterscript.");
          }
          auditWorkItemOwnerHistory(item);
          auditWorkItemComments(item);
          wfcontext.getSailPointContext().commitTransaction();
      }

      /**
       * Convert the approvalScheme to csv and check for the approvalType.
       */
      public boolean isApprovalEnabled(String approvalScheme, String approvalType) {
          if ( approvalScheme != null )  {
              List schemes = Util.csvToList(approvalScheme);
              if ( Util.size(schemes) > 0 ) {
                  if ( schemes.contains(approvalType) ) {
                      return true;
                  }
              }
          }
          return false;
      }

      public String getManagerName(String identityName, String launcher, String fallbackApprover) {
          String managerName = getIdentityProperty(identityName, "manager.name");
          if ( managerName != null ) {
              if ( managerName.compareTo(launcher) == 0 ) {
                  managerName = null;
              } 
          } else {
             managerName = fallbackApprover;
          }
          return managerName;
      }

      /**
       * Take an ApprovalSet and allow filtering of rejected items and 
       * allow clearing decisions. If includeRejected is false, only non rejected 
       * items will be copied into the new approvalSet.   If forceDecision is
       * true all of the previous decisions will be cleared forcing the new
       * approver to make a decision on all items.
       */
      public ApprovalSet filterApprovalSet(ApprovalSet masterSet, String includeRejected, 
                                           boolean forceDecision) {
          ApprovalSet filtered = new ApprovalSet();
          if ( masterSet != null ) {
              List items = masterSet.getItems();
              if ( !Util.otob(includeRejected) ) {
                  items = new ArrayList();
                  for ( ApprovalItem item : masterSet.getItems() ) {
                      if ( !item.isRejected() ) {
                          items.add(item);
                      }
                  }
              }
 
              if ( Util.size(items) > 0 )  {
                  for ( ApprovalItem item : items ) {
                      if ( forceDecision ) { 
                          item.setState(null);
                      }
                      filtered.add(item); 
                  } 
              } 
          }
          return filtered;
      }

      //Filter items from the currentSet that are rejected in the masterSet
      public void filterRejectsFromApprovalSet(ApprovalSet masterSet, ApprovalSet currentSet) {
        if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            Iterator it = currentSet.getItems().iterator();
            while(it.hasNext()) {
                ApprovalItem currentItem = (ApprovalItem)it.next();
                //Find the item in the global ApprovalSet
                ApprovalItem globalItem = masterSet.find(currentItem);
                if (globalItem != null &amp;&amp; globalItem.isRejected()) {
                    //remove from the current approval
                    it.remove();
                }
            }
        }

      }

      //Set decisions on the currentSet to those in the masterSet
      public void setPreviousDecisionsOnApprovalSet(ApprovalSet masterSet, ApprovalSet currentSet) {
        if (currentSet != null &amp;&amp; !Util.isEmpty(currentSet.getItems())) {
            Iterator it = currentSet.getItems().iterator();
            while(it.hasNext()) {
                ApprovalItem currentItem = (ApprovalItem)it.next();
                //Find the item in the global ApprovalSet
                ApprovalItem globalItem = masterSet.find(currentItem);
                if (globalItem != null) {
                    currentItem.setState(globalItem.getState());
                }
            }
        }
      }

    
  </Source>
  </Rule>
  <Rule created="1651241698922" id="c0a8010480751c5d818075acc66a0189" language="beanshell" modified="1662117629674" name="Check Password Policy" type="FieldValue">
    <Source>
    
       import sailpoint.api.PasswordPolice;
       import sailpoint.object.Application;
       import sailpoint.object.Identity;
       import java.util.List;
       import java.util.ArrayList;
       import sailpoint.api.PasswordPolicyException;
       import sailpoint.tools.Util;
       import sailpoint.tools.Message;
       import sailpoint.tools.GeneralException;

       List msgs = new ArrayList();

       String passVal = (String)value;

       try {
           String appname = field.getApplication();
           if (appname == null) {
              // temporary support old WorkItems
              String fname = field.getName();
              int colon = fname.indexOf(":");
              if (colon > 0)
                 appname = fname.substring(0, colon);
              else
                 log.error("Unable to determine application name from field");
           }
           Application app = context.getObjectByName(Application.class, appname);
          
           PasswordPolice police = new PasswordPolice(context);
           police.checkPassword(app, identity, passVal);
       }
       catch (PasswordPolicyException pe) {
           List messages = pe.getAllMessages();
           for (Message msg : messages) {
               msgs.add(msg.getMessage());
           }
       }
       catch (GeneralException ge) {
           msgs.add(ge.getMessage());
       }

       return ( Util.size(msgs) > 0 ) ? msgs: null;
    
  </Source>
  </Rule>
  <Rule created="1651241699121" id="c0a8010480751c5d818075acc731018a" language="beanshell" modified="1662117629826" name="LCM Build Owner Approvals">
    <ReferencedRules>
      <Reference class="sailpoint.object.Rule" id="c0a8010480751c5d818075acbfa80168" name="Approval Library"/>
    </ReferencedRules>
    <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.workflow.IdentityLibrary;

       //
       // Attributes needed in the rule context: 
       //
       // plan - ProvisioningPlan object 
       //
       // approvalSet - An ApprovalSet representing the "cart"
       // 
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //
       //
       List approvals = new ArrayList();
       if ( approvalSet != null ) {
           // 
           // Build a map of owner to ApprovalSet from each of the things in the plan 
           // 
           Map ownerMap = buildOwnerMap("owner", approvalSet, plan, fallbackApprover, identityName, !IdentityLibrary.isElectronicSignatureEnabled(wfcontext));
           if ( ownerMap != null) {
               approvals = buildApprovalsFromMap(ownerMap, identityName, launcher);
           } 
       }
       return ( Util.size(approvals) > 0 ) ? approvals : null;
    
  </Source>
  </Rule>
  <Rule created="1651241699346" id="c0a8010480751c5d818075acc812018b" language="beanshell" modified="1662117629948" name="LCM Build Identity Approvers">
    <ReferencedRules>
      <Reference class="sailpoint.object.Rule" id="c0a8010480751c5d818075acbfa80168" name="Approval Library"/>
    </ReferencedRules>
    <Source>
    
       import sailpoint.object.ApprovalSet;
       import sailpoint.object.ProvisioningPlan;
       import sailpoint.object.WorkItem.State;
       import sailpoint.workflow.IdentityLibrary;
       import sailpoint.tools.Util;

       //
       // Attributes needed in the rule context: 
       //
       // plan - ProvisioningPlan object 
       //
       // approvalScheme - String indicating how approvals should be generated
       //   none - disabled
       //   manager - the current manager gets the approval
       //   newManager - the current manager if the manager changd
       //   securityOfficer - the configured security officer
       // 
       // approvalSet - An ApprovalSet representing the "cart"
       //
       // fallbackApprover - String representing who gets the approval
       //                    if we can't resolve one.  
       //
       // identityName - name of the identity being operated on
       //
       // launcher - name of the identity that launched the request
       //
       // securityOfficerName - The name of the securityOfficer to be used
       //                       for approvals.
       //

       // Not all callers pass in securityOfficerName.  If not defined, just set
       // it to null so we don't run into an error when we try to reference it.
       if (void == securityOfficerName) {
           securityOfficerName = null;
       }

       List approvers = new ArrayList();
       if ( approvalSet != null ) {
           List items = approvalSet.getItems();
           // By default there is one item for all of the edits
           ApprovalItem item = null;
           if ( Util.size(items) > 0 ) 
               item = items.get(0); 

           if ( item != null ) {
               approvers = getApproverNames(approvalScheme, item, plan, identityName, securityOfficerName);
               if ( approvers != null &amp;&amp; approvers.size() == 0 &amp;&amp; fallbackApprover != null ) {
                   if ( log.isDebugEnabled() ) { 
                       log.debug("Approver could not be resolved using fallbackApprover '"+fallbackApprover+"'.");
                   }
                   approvers.add(fallbackApprover);
               } 
               // If the launcher is an approver remove them from the list
               if ( approvers != null &amp;&amp; approvers.contains(launcher) ) {
                   Map args = wfcontext.getArguments();
                   String esig = null;
                   if ( args != null ) 
                       esig = (String)args.get("approverElectronicSignature");
 
                   if ( !IdentityLibrary.isElectronicSignatureEnabled(wfcontext) &amp;&amp; Util.isNullOrEmpty(esig) ) {
                       approvers.remove(launcher);
                       // If this is the only approver automaticaly
                       // mark the item approved.
                       if ( Util.size(approvers) == 0 ) {
                           item.setState(WorkItem.State.Finished);
                           item.setOwner(launcher);
                       }
                   }
               }
           }
       }
       return approvers;
    
  </Source>
  </Rule>
  <Rule created="1651241699533" id="c0a8010480751c5d818075acc8cd018c" language="beanshell" modified="1662117630070" name="LCM Validate Identity Name" type="Validation">
    <Source>
    
      import sailpoint.api.*;
      import sailpoint.object.*;
      import sailpoint.tools.*;
      import sailpoint.api.*;
      import sailpoint.web.messages.MessageKeys;

      List messages = new ArrayList();
      QueryOptions qo = new QueryOptions();
      String trimValue = (value != null) ? ((String)value).trim() : null;
      if (trimValue == null || "".equals(trimValue)) {
          Message msg = new Message();
          msg.setKey(MessageKeys.LCM_CREATE_IDENTITY_NO_NAME_ERROR);
          messages.add(msg);
      } else {
          Filter filter  = Filter.or(Filter.eq("id", trimValue), Filter.ignoreCase(Filter.eq("name", trimValue)));
          qo.add(new Filter[]{filter});
          qo.addFilter(ObjectUtil.buildWorkgroupInclusiveIdentityFilter());
          int count = SailPointFactory.getCurrentContext().countObjects(Identity.class,qo);
          if (count>0) {
              Message msg = new Message();
              msg.setKey(MessageKeys.LCM_CREATE_IDENTITY_NAME_ERROR);
              messages.add(msg);
          }
      }
      return messages;
    
  </Source>
  </Rule>
  <Rule created="1651241699686" id="c0a8010480751c5d818075acc966018d" language="beanshell" modified="1662117630208" name="LCM Validate Password" type="Validation">
    <Source>
    
      import java.util.*;
      import sailpoint.api.PasswordPolice;
      import sailpoint.api.PasswordPolicyException; 
      
      List errors = null;
      
      try {
          PasswordPolice pp = new PasswordPolice(context);
          pp.checkPassword(null, value, false);
      }
      catch (PasswordPolicyException ppe) {
          errors = new ArrayList();
          errors.addAll(ppe.getAllMessages());
      }
      
      return errors;
    
  </Source>
  </Rule>
  <Rule created="1651241700065" id="c0a8010480751c5d818075accae1018e" language="beanshell" modified="1662117630473" name="LCM Build Identity ApprovalSet">
    <ReferencedRules>
      <Reference class="sailpoint.object.Rule" id="c0a8010480751c5d818075acbfa80168" name="Approval Library"/>
    </ReferencedRules>
    <Source>
    
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ApprovalSet;
      import sailpoint.object.ApprovalItem;
      import sailpoint.object.Attributes;
      import sailpoint.tools.Util;

      ApprovalSet set = new ApprovalSet();
      if ( plan != null ) {
          List accountRequests = plan.getAccountRequests();
          for ( AccountRequest request : accountRequests ) {
              ApprovalItem item = new ApprovalItem();
              item.setApplication(request.getApplication());
              item.setInstance(request.getInstance());
              item.setNativeIdentity(request.getNativeIdentity());
              item.setOperation(request.getOperation().toString());
              List attrRequestFlat = flattenAttributeRequests(request.getAttributeRequests());
              if ( attrRequestFlat != null ) {
                  item.setValue(attrRequestFlat);
              } 
              Attributes attributes = getAttributeRequestArguments(request.getAttributeRequests());
              item.setAttributes(attributes);
              
              // for these requests comments come in on the plan
              String comments = plan.getComments();
              if ( Util.getString(comments) != null ) {
                  item.setRequesterComments(comments);
              }
              set.add(item);
          }

          // while we are here lets annotate the plan with previousValues
          if ( flow.equals("IdentityEditRequest") ) {
              AccountRequest iiqRequest = plan.getAccountRequest("IIQ");    
              if ( iiqRequest != null ) {
                  List attributeRequests = iiqRequest.getAttributeRequests();
                  if ( Util.size(attributeRequests) > 0 ) {
                      Identity id = context.getObject(Identity.class, identityName);
                      if ( id != null )  {
                          for ( AttributeRequest req : attributeRequests ) {
                              String name = req.getName();
                              if ( name != null ) {
                                  // We have to be carefull here, if we see manager display
                                  // the displayName
                                  Object prevValue = id.getAttribute(name);
                                  if ( prevValue != null ) {
                                      if (name.equals("manager") ) {
                                          String displayName = getIdentityProperty((String)prevValue, "displayName");
                                          if ( displayName != null ) {
                                              prevValue = displayName;
                                          }
                                      }
                                      else if (prevValue instanceof Identity) {
                                          prevValue = (String)prevValue.getDisplayableName();
                                      }
                                      else  if(prevValue instanceof List) {
                                          /* Thanks to type erasure there is no way for us to write something like
                                           * prevValue instanceof List&lt;Identity> so break it into steps.  Check if
                                           * prevValue is a List.  If it has any elements get the first one. If that
                                           * is an instance of Identity then assume the rest of the elements are too
                                           * and then build a List of displayable names, because that is what we do
                                           * with Identitys. */
                                          List prevValueList = (List) prevValue;
                                          if(prevValueList.size() > 0) {
                                              if(prevValueList.get(0) instanceof Identity) {
                                                  List identityIds = new ArrayList(prevValueList.size());
                                                  for (Object value : prevValueList) {
                                                      Identity identity = (Identity) value;
                                                      identityIds.add(identity.getDisplayableName());
                                                  }
                                                  prevValue = identityIds;
                                              }
                                          }
                                      }
                                      req.put(ProvisioningPlan.ARG_PREVIOUS_VALUE, prevValue);
                                  }
                              }
                          }
                      }
                  }
              }
          }
      }
      return set;
    
  </Source>
  </Rule>
  <Rule created="1651241700234" id="c0a8010480751c5d818075accb8a018f" language="beanshell" modified="1662117630581" name="Objects in Requestor&apos;s Authorized Scopes" type="RequestObjectSelector">
    <Description>
    This rule returns either a Filter object that will be used to search for objects in the requestor's authorized scopes,
    the boolean value 'true' to indicate that everything should be returned (i.e. no restrictions) 
    or the boolean value 'false' to indicate that no objects are available for this user
  </Description>
    <Signature returnType="sailpoint.object.QueryInfo">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="requestor" type="sailpoint.object.Identity">
          <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
        </Argument>
        <Argument name="requestee" type="sailpoint.object.Identity">
          <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="filter">
          <Description>
          Either a Filter object that will be used to search for accessible Objects, the boolean value 'true' to indicate that everything should be
          returned (i.e. no restrictions) or the boolean value 'false' to indicate that no objects are available for this population 
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>
    
      import sailpoint.api.ScopeService;
      
      ScopeService scopeService = new ScopeService(context);
      return scopeService.getControlledScopesQueryInfo(requestor);
    
  </Source>
  </Rule>
  <Rule created="1651241700443" id="c0a8010480751c5d818075accc5b0190" language="beanshell" modified="1662117630707" name="Objects in Requestee&apos;s Assigned Scope" type="RequestObjectSelector">
    <Description>This rule returns a Filter that restricts objects to those in the requestee's assigned scope</Description>
    <Signature returnType="sailpoint.object.QueryInfo">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="requestor" type="sailpoint.object.Identity">
          <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
        </Argument>
        <Argument name="requestee" type="sailpoint.object.Identity">
          <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the objects that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="filter">
          <Description>
          Either a Filter object that will be used to search for accessible Objects, the boolean value 'true' to indicate that everything should be
          returned (i.e. no restrictions) or the boolean value 'false' to indicate that no objects are available for this population 
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>
    
      import sailpoint.api.ScopeService;
      import sailpoint.object.Identity;
      import sailpoint.object.Scope;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.QueryInfo;

      ScopeService scopeService = new ScopeService(context);
      QueryInfo scopeQueryInfo;
      if (requestee == null) {
          scopeQueryInfo = new QueryInfo(new QueryOptions());
      } else {
          scopeQueryInfo = scopeService.getAssignedScopeQueryInfo(requestee);
      }
      
      return scopeQueryInfo;
    
  </Source>
  </Rule>
  <Rule created="1651241700616" id="c0a8010480751c5d818075accd080191" language="beanshell" modified="1662117630871" name="Objects in Requestor&apos;s Authorized Scopes or Requestee&apos;s Assigned Scope" type="RequestObjectSelector">
    <Description>This rule returns a Filter that restricts roles to those in the requestor's authorized scopes or the requestee's assigned scope</Description>
    <Signature returnType="sailpoint.object.QueryInfo">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="requestor" type="sailpoint.object.Identity">
          <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
        </Argument>
        <Argument name="requestee" type="sailpoint.object.Identity">
          <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="filter">
          <Description>
          A Filter object that will be used to search for accessible objects.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>
    
        import sailpoint.api.ScopeService;
        import sailpoint.object.Filter;
        import sailpoint.object.Identity;
        import sailpoint.object.QueryInfo;
        import sailpoint.object.QueryOptions;        

        ScopeService scopeService = new ScopeService(context);
        QueryInfo requestorQueryInfo =  scopeService.getControlledScopesQueryInfo(requestor);
        QueryInfo requesteeQueryInfo;
        if (requestee == null) {
            requesteeQueryInfo = null;
        } else {
            requesteeQueryInfo =  scopeService.getAssignedScopeQueryInfo(requestee);
        }

        QueryInfo scopeQueryInfo;
        if (requesteeQueryInfo == null || requesteeQueryInfo.isReturnNone()) {
            // Either no requestee was available or the requestee doesn't have anything in scope.  
            // Only apply the requestor QueryInfo in either case.
            scopeQueryInfo = requestorQueryInfo;
        } else if (requestorQueryInfo != null &amp;&amp; !requestorQueryInfo.isReturnNone()) {
            if (requestorQueryInfo.isReturnAll() || requesteeQueryInfo.isReturnAll()) {
                // If either the requestor or requestee has access to everything create a QueryInfo that grants
                // access to everything
                scopeQueryInfo = new QueryInfo(new QueryOptions());
            } else {
                // Both requestee and requestor filters exist so 'or' them
                scopeQueryInfo = new QueryInfo(Filter.or(requestorQueryInfo.getFilter(), requesteeQueryInfo.getFilter()), false);
            }
        } else {
            // The requestor doesn't have access to anything so only return whatever the requestee has access to
            scopeQueryInfo = requesteeQueryInfo;
        }

        return scopeQueryInfo;
    
  </Source>
  </Rule>
  <Rule created="1651241700803" id="c0a8010480751c5d818075accdc30192" language="beanshell" modified="1662117631002" name="Objects Owned by the Requestor" type="RequestObjectSelector">
    <Description>This rule returns a Filter that restricts objects to those that the requestor or one of their workgroups owns</Description>
    <Signature returnType="sailpoint.object.QueryInfo">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="requestor" type="sailpoint.object.Identity">
          <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
        </Argument>
        <Argument name="requestee" type="sailpoint.object.Identity">
          <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the objects that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected object.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="filter">
          <Description>
          A Filter object that will be used to search for accessible Objects.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>
    
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.QueryInfo; 
      return new QueryInfo(QueryOptions.getOwnerScopeFilterUsingSubqueries(requestor, "owner"), false);
    
  </Source>
  </Rule>
  <Rule created="1651241700973" id="c0a8010480751c5d818075acce6d0193" language="beanshell" modified="1662117631124" name="All Objects" type="RequestObjectSelector">
    <Description>Allows all objects to be selected (no filtering)</Description>
    <Signature returnType="sailpoint.object.Filter">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="requestor" type="sailpoint.object.Identity">
          <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
        </Argument>
        <Argument name="requestee" type="sailpoint.object.Identity">
          <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="filter">
          <Description>
          A Filter object that will be used to search for accessible request objects.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import sailpoint.object.QueryInfo;

return new QueryInfo(null, false);</Source>
  </Rule>
  <Rule created="1651241703582" id="c0a8010480751c5d818075acd89e01e5" language="beanshell" modified="1662117620453" name="Identity Report Form Customizer" type="ReportCustomizer">
    <Description>
    This rule populates a form with fields for the standard and extended identity attributes.
  </Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="locale">
          <Description>
          The current user's locale
        </Description>
        </Argument>
        <Argument name="report">
          <Description>
          The base report
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, Identity.class, standardAttributes, null,
          "Identity Attributes", locale, "id");

        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, Identity.class, extendedAttrs, null,
          "Identity Extended Attributes", locale, "id");


       
</Source>
  </Rule>
  <Rule created="1651241704369" id="c0a8010480751c5d818075acdbb101e8" language="beanshell" modified="1662117620593" name="Identity Entitlement Identity Report Form Customizer" type="ReportCustomizer">
    <Description>
    This rule populates a form with fields for the standard and extended identity attributes accessed through an identity entitlement.
  </Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="locale">
          <Description>
          The current user's locale
        </Description>
        </Argument>
        <Argument name="report">
          <Description>
          The base report
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, IdentityEntitlement.class, standardAttributes, "identity",
          "Identity Attributes", locale, "id");


        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, IdentityEntitlement.class, extendedAttrs, "identity",
          "Identity Extended Attributes", locale, "id");


       
</Source>
  </Rule>
  <Rule created="1651241704666" id="c0a8010480751c5d818075acdcda01ea" language="beanshell" modified="1662117620733" name="Account Report Form Customizer" type="ReportCustomizer">
    <Description>
    This rule populates a form with fields for all searchable account fields.
  </Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="locale">
          <Description>
          The current user's locale
        </Description>
        </Argument>
        <Argument name="report">
          <Description>
          The base report
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig linkConfig = ObjectConfig.getObjectConfig(Link.class);
        ReportingLibrary.addAttributes(context, report, Link.class, linkConfig.getSearchableAttributes(), null,
          "Account Properties", locale);
       
</Source>
  </Rule>
  <Rule created="1651241705402" id="c0a8010480751c5d818075acdfba0204" language="beanshell" modified="1662117621232" name="Certification Report Customizer" type="ReportCustomizer">
    <Source>
       
        import sailpoint.object.*;
        import sailpoint.tools.Util;
        import sailpoint.web.messages.MessageKeys;
        if (Util.otob(taskDefinition.getArgument("exclusions"))){
          report.setDisablePreview(true);
          report.setDisablePreviewMessage(MessageKeys.REPT_CERT_PREVIEW_DISABLED_EXCLUSIONS);
        } else {
          report.setDisablePreview(false);
          report.setDisablePreviewMessage(null);
        }

       
</Source>
  </Rule>
  <Rule created="1651241706067" id="c0a8010480751c5d818075ace253021c" language="beanshell" modified="1662117620875" name="Privileged Access Report Customizer" type="ReportCustomizer">
    <Description>
    This rule populates a form with fields for the standard and extended identity attributes as well as
    a form for defining the 'privileged' identity attribute.
  </Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="locale">
          <Description>
          The current user's locale
        </Description>
        </Argument>
        <Argument name="report">
          <Description>
          The base report
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>
       
        import sailpoint.object.*;
        import sailpoint.reporting.ReportingLibrary;

        ObjectConfig linkConfig = ObjectConfig.getObjectConfig(Link.class);
        ReportingLibrary.addAttributes(context, report, Link.class, linkConfig.getSearchableAttributes(), null,
          "Privileged Account Attributes", locale, "id");


        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);
        List standardAttributes = new ArrayList();
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("firstname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("lastname"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("displayName"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("email"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("manager"));
        standardAttributes.add(identityConfig.getObjectAttributeMap().get("inactive"));

        ReportingLibrary.addAttributes(context, report, Identity.class, standardAttributes, "identity",
          "Identity Properties", locale, "id");

        List extendedAttrs = new ArrayList();
        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){
          if (!att.isStandard())
            extendedAttrs.add(att);
        }

        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){
            extendedAttrs.add(att);
        }

        ReportingLibrary.addAttributes(context, report, Identity.class, extendedAttrs, "identity",
          "Identity Extended Properties", locale, "id");
       
</Source>
  </Rule>
  <Rule created="1651241706201" id="c0a8010480751c5d818075ace2d9021d" language="beanshell" modified="1662117620998" name="Privileged Access Report Validation Rule" type="ReportValidator">
    <Description>
      This rule validates the Privileged Access Report Form
    </Description>
    <Signature returnType="java.util.List">
      <Inputs>
        <Argument name="context">
          <Description>
            A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
          </Description>
        </Argument>
        <Argument name="report">
          <Description>
            The report object
          </Description>
        </Argument>
        <Argument name="form">
          <Description>
            The submitted sailpoint Form object.
          </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="messages">
          <Description>
            A list of error messages.
          </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>
      
       import java.util.*;
       import sailpoint.object.*;
       import sailpoint.tools.Message;
       List messages = new ArrayList();

       Form.Section section = form.getSection("Privileged Account Attributes");
       if (section != null) {
         boolean found = false;
         for(FormItem item : section.getItems()){
           Field field = (Field)item;
           if(field.getValue() != null &amp;&amp; !field.getValue().equals("") &amp;&amp; !field.getValue().equals("null")) {
             found = true;
           }
         }

         if (!found) {
           messages.add(Message.localize("rept_priv_access_err_no_attr"));
         }
       } else {
         messages.add(Message.localize("rept_priv_attr_setup_needed"));
       }

       return messages;
      
  </Source>
  </Rule>
  <Rule created="1651241717665" id="c0a8010480751c5d818075ad0fa10299" language="beanshell" modified="1655896209161" name="WindowsActivityRuleLibrary">
    <Source>
    
      import java.util.HashMap;
      import java.util.ArrayList;
      import java.util.List;
      import sailpoint.object.ApplicationActivity;
      import sailpoint.object.ApplicationActivity.Action;
      import sailpoint.tools.xml.*;

      public static String ACCESSES = "Accesses";
      public static String PRIVS = "Privileges";

      /**
       * Build a name,value Map pairing of the data found
       * in the Message field of the windows event.
       * Most of the low-level data is usually stored 
       * there using a "name : value \n" format, so parse
       * out those values so we can use them when 
       * building our activity.
       */
      public HashMap buildMapFromMessage(String message) {
  
          HashMap attributeMap = new HashMap();
          if ( message == null ) return attributeMap;

          StringTokenizer st = new StringTokenizer(message, "\n");
          int tokenNum = 0;
          while ( st.hasMoreTokens() ) {
              tokenNum++;
              String token = st.nextToken();
//System.out.println("token :" + token);
              String[] values = token.split(":");
              if ( values == null ) continue;
              if ( values.length == 2 ) {
                  String name = values[0];
                  String value = values[1];
                  if ( ( name != null ) &amp;&amp; ( value != null ) ) {
//System.out.println("name: " + name.trim() + " value: " + value.trim());
                      attributeMap.put(name.trim(), value.trim());
                  }
              } else 
              if ( (values.length == 1) &amp;&amp; (tokenNum == 1) ) {
                  String name = values[0];
                  attributeMap.put("action", name.trim());
              }
          }
          // Parse out privs 
          addPrivileges(attributeMap, message); 

          return attributeMap;
      }

      /** 
       * Some events, mostly Object Access events contain
       * Accesses, Privleges that need to be parsed further.
       * This is called, when we build a Map if the Message.
       */
      public void addPrivileges(HashMap extraInfo, String message) {

          if ( message== null ) return;
          int i = message.indexOf(ACCESSES);
          if ( i == -1 ) {
//System.out.println(ACCESSES + " not found");
              return;
          }
          int j = message.indexOf(PRIVS);
          if ( j == -1 ) {
//System.out.println(PRIVS + " not found");
              return;
          }

          List accesses = new ArrayList();
          String lastBlock = message.substring(i+ACCESSES.length(), j-1);
          if ( lastBlock != null ) {
//System.out.println("***lastBlock: " + lastBlock);
              StringTokenizer st = new StringTokenizer(lastBlock, "\n");
              while ( st.hasMoreTokens() ) {
                  String access = st.nextToken();
                  if ( access != null ) {
                      String trimed = access.trim();
                      if ( trimed.length() > 0 ) {
//System.out.println("access: '" + trimed + "'");
                          accesses.add(trimed);
                      }
                  }
              }
          }

          if ( accesses.size() > 0 ) {
              extraInfo.put(ACCESSES, accesses);
          }
      }

      /**
       * Given the eventCode from the native windows event
       * map it to our Action.
       */
      public Action resolveAction(Integer eventCode, HashMap extraInfo) {
          Action action = null;

          if ( eventCode == null ) {
              return;
          }

          try {
              switch(eventCode) {
                  case 538:
                      // logout
                      action = Action.Logout;
                      break;
                  case 528:
                  case 540:
                      // login
                      action = Action.Login;
                      break;
                  case 564:
                      // object delted
                      action = Action.Delete;
                      break;
                  case 560:
                      // object open
                      // Very generic must dig in an check permissions
                      if (containsAccess("WriteAttributes", extraInfo))
                          action = Action.Update;
                      else
                      if ( containsAccess("DELETE", extraInfo) ) 
                          action = Action.Delete;
                      else 
                          action = Action.Read;
                      break;
                  default: 
                      // not sure we should even have a default case?
                      action = Action.Read;
                      break;
              }
          } catch(Exception e) {
              action = null;
          }
          return action;
      }

      /** 
       * Using the resolved action, use the data in the extraInfo
       * map to come up with a target. ( the thing that was acted upon)
       */
      public String resolveTarget(Action action, HashMap extraInfo) {

          String target = null;    
          if ( ( action == null ) || ( extraInfo == null )  ) {
              return target;
          }

          if ( ( action.equals(Action.Login) ) ||
               ( action.equals(Action.Logout) ) ) {
              target = (String)extraInfo.get("Domain");
          } else {
              target = (String)extraInfo.get("Object Name");
          }

          if ( target == null ) target = "unResolved";
          return target;
      }


      /** 
       * Dig into the extra info and see if the event has referece to 
       * the past in access. 
       */
      private boolean containsAccess(String access, HashMap extraInfo) {

          boolean contains = false;
          if ( extraInfo == null ) return contains;

          ArrayList accesses = (ArrayList)extraInfo.get(ACCESSES); 
          if ( accesses != null ) {
              for ( String access: accesses ) {
                  if ( access != null ) {
                      if ( access.compareTo(access) == 0 ) {
                          return true;
                      }
                  }
              }        
          }
          return contains;
      }
    
  </Source>
  </Rule>
  <Rule created="1651241718503" id="c0a8010480751c5d818075ad12e702a0" language="beanshell" modified="1662117619625" name="System Configured Locale Rule" type="FieldValue">
    <Description>
    This rule returns the locales configured in the System Configuration.
  </Description>
    <Signature returnType="java.util.List">
      <Inputs>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="locales">
          <Description>
          A list containing the locales found in the System Configuration.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>
      import java.util.*;
     Map sysConfig = context.getConfiguration().getAttributes();
     List locales = sysConfig.get("supportedLanguages");
     return locales;
</Source>
  </Rule>
  <Rule created="1651241718656" id="c0a8010480751c5d818075ad138002a1" language="beanshell" modified="1662117620328" name="Report Completion Notification" type="TaskEventRule">
    <Description>
    This rule sends a notification email when a report is completed.
  </Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="taskResult">
          <Description>
          The TaskResult object
        </Description>
        </Argument>
        <Argument name="event">
          <Description>
          The TaskEvent object
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="taskResult">
          <Description>The resulting task result object, or null if no update is required.</Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>
      
        import sailpoint.object.*;
        import java.util.*;

        String identity = (String)event.getAttribute(TaskEvent.ATTR_EMAIL_RECIP);

        if (identity != null){

          Identity identity = context.getObjectByName(Identity.class, identity);
          if (identity == null)
            return result;

          List emailAddresses = new ArrayList();
          emailAddresses.add(identity.getEmail());
          EmailOptions options = new EmailOptions(emailAddresses, null);
          options.setSendImmediate(true);

          Map emailVars = new HashMap();
          emailVars.put("reportName", taskResult.getName());
          options.setVariables(emailVars);

          String templateName = (String)context.getConfiguration().get(Configuration.REPORT_COMPLETION_EMAIL_TEMPLATE);
          EmailTemplate et = context.getObjectByName(EmailTemplate.class, templateName);

          context.sendEmailNotification(et, options);
        }

        return null;
      
</Source>
  </Rule>
  <Rule created="1651241719524" id="c0a8010480751c5d818075ad16e402a2" language="beanshell" modified="1662117621113" name="Report Scorecard Value Renderer">
    <Description>
      This rule renders report columns which pull values from a Scorecard object.
    </Description>
    <Source>
      
       import java.util.*;
       import sailpoint.object.*;

       Integer score = null;
       if(value!=null) {
					score = value.getScore(column.getField());
			 }

       return score != null ? score.toString() : null;
      
  </Source>
  </Rule>
  <Rule created="1651241719892" id="c0a8010480751c5d818075ad185402a4" language="beanshell" modified="1662117621386" name="Task Completion Email Rule" type="TaskCompletion">
    <Description>
      Example rule to perform Post Action after Task Completion
    </Description>
    <Signature>
      <Inputs>
        <Argument name="context">
          <Description>
            A sailpoint.api.SailPointContext object 
          </Description>
        </Argument>
        <Argument name="log">
          <Description>
            The log object associated with the SailPointContext.
          </Description>
        </Argument>
        <Argument name="result">
          <Description>
            result of task.
          </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>
      
          import java.util.*;
          import sailpoint.tools.Util;
          import sailpoint.tools.GeneralException;
          import sailpoint.object.Configuration;
          import sailpoint.object.EmailOptions;
          import sailpoint.object.EmailTemplate;
          import sailpoint.object.TaskResult;
          import sailpoint.object.Identity;
          import sailpoint.object.TaskDefinition;
          import sailpoint.api.MessageRepository;
          import sailpoint.api.Emailer;
          import sailpoint.api.BasicMessageRepository;
          import sailpoint.api.ObjectUtil;
          import sailpoint.api.SailPointContext;

          MessageRepository _errorHandler;

          /**
           * Method to send email
          */
          private void sendEmailOnTaskCompletion(String emailTemplate, ArrayList recipients, TaskResult result, SailPointContext context) {
              String message = "";
              String status = "";
              TaskDefinition def;
              Configuration sysConfig;

              def = result.getDefinition();
              EmailTemplate notifyEmail =  context.getObjectByName(EmailTemplate.class, emailTemplate);
              if (null == notifyEmail) {
                  log.error ("From Task Completion Email Rule: ERROR: could not find email template [ " + emailTemplate + "]");
                  return;
              }
              notifyEmail = (EmailTemplate) notifyEmail.deepCopy(context);
              if (null == notifyEmail) {
                  log.error ("From Task Completion Email Rule: ERROR: failed to deepCopy template [ " + emailTemplate + "]");
                  return;
              }
              // For now, we'll just use a map with a few pre-selected properties.
              Map mArgs = new HashMap();
 
              mArgs.put("taskResult", result);
              mArgs.put("taskName", def.getName());
              mArgs.put("taskDesc", def.getDescription());
              if (result.isError()) {
                  status = "Error";
              }
              else  if (result.isWarning()) {
                  status = "Warning";
              }
              else if (result.isSuccess()) {
                  status = "Success";
              }
 
              mArgs.put("taskStartTime", result.getLaunched() );
              mArgs.put("taskEndTime", result.getCompleted() );
              mArgs.put("status", status);
              if (result.getMessages() != null) {
                  mArgs.put("message", result.getMessages());
              }
              mArgs.put ("resultId", result.getId());

              EmailOptions ops = new EmailOptions(recipients, mArgs);
              new Emailer(context, _errorHandler).sendEmailNotification(notifyEmail , ops);
          }

          private boolean isEmailNotificationEnabled(TaskResult result, Configuration sysConfig) {
              boolean sendEmail = false;
              String notifyStr = null;

              TaskDefinition def = result.getDefinition();
              notifyStr = (String) def.getString(Configuration.TASK_COMPLETION_EMAIL_NOTIFY);

              if (notifyStr == null || notifyStr.equals("Disabled")) {
                  // if Disabled in TaskDef, defer to System Config
                  notifyStr = sysConfig.getString(Configuration.TASK_COMPLETION_EMAIL_NOTIFY);
              }

              if (notifyStr != null) {
                  if (notifyStr.equals("Always") ||
                      ((notifyStr.equals("Failure")) &amp;&amp; result.isError()) || 
                      ((notifyStr.equals("Warning")) &amp;&amp;
                       (result.isWarning() || result.isError()))) {
                      sendEmail = true;
                  }
              }
                      
              return sendEmail;
          }

          private Object getIdentityNames(TaskResult result, Configuration sysConfig) {
              
              TaskDefinition def = result.getDefinition();
              Object identityNames = def.getArgument(Configuration.TASK_COMPLETION_RECIPIENTS);
              if (identityNames == null) {
                  identityNames = sysConfig.get(Configuration.TASK_COMPLETION_RECIPIENTS);
              }
              return identityNames;
          }

          private String getEmailTemplate(TaskResult result, Configuration sysConfig) {
              TaskDefinition def = result.getDefinition();
              String emailTemplate = def.getString(Configuration.TASK_COMPLETION_EMAIL_TEMPLATE);
              if (emailTemplate == null) {
                  emailTemplate = sysConfig.getString(Configuration.TASK_COMPLETION_EMAIL_TEMPLATE);
                  if (emailTemplate == null)
                      emailTemplate = Configuration.DEFAULT_TASK_COMPLETION_EMAIL_TEMPLATE;
              }
              return emailTemplate;
          }

          private List getEmailAddress (String identityName, SailPointContext context) {
              Identity identity = context.getObjectByName(Identity.class, identityName);
              if (identity != null) 
              {
                  List addresses = ObjectUtil.getEffectiveEmails(context, identity);
                  if (!Util.isEmpty(addresses)) {
                      return(addresses);
                  }
                  else
                  {
                     if(log.isWarnEnabled()) {
                         log.warn("From Task Completion Email Rule: Missing Email Address for Email Recipient: " + identityName );
                     }
                  }
              }
              return (null);
          }

          private ArrayList getEmailRecipient (Object identityNames, SailPointContext context) {
              List recipients;
              String val = null;
              StringTokenizer st = null;
              if (identityNames != null) {
                  recipients = new ArrayList ();
                  // From Task definition, single identity
                  if (identityNames instanceof String  &amp;&amp; !identityNames.contains(",")) {
                      List addresses = getEmailAddress (identityNames.toString(), context);
                      if (addresses != null) {
                         recipients.addAll (addresses);
                      }
                  }
                  // From Task definition, multiple identities
                  else if (identityNames instanceof String  &amp;&amp; identityNames.contains(",") == true) {
                      List nameList = Util.csvToList(identityNames);
                      for (String identityName : nameList) {
                          List addresses = getEmailAddress (identityName, context);
                          if (addresses != null) {
                              recipients.addAll (addresses);
                          }
                      }  
                  } 
                  // From system configuration single or multiple identities it comes as list
                  else if (identityNames instanceof List) {
                      for (String identityName : identityNames) {
                          List addresses = getEmailAddress (identityName, context);
                          if (addresses != null) {
                              recipients.addAll(getEmailAddress (identityName, context));
                          }
                      }
                  }
              }
              return (recipients);
          }

          // Main
          Configuration sysConfig = context.getConfiguration();
          boolean sendEmailNotify = isEmailNotificationEnabled(result, sysConfig);
    
          if (sendEmailNotify) {
              // jsl - why consturct this here, just make it in
              // sendEmailOnTaskCompletion where it is used?
              // why do this at all since no one consumes it?
              _errorHandler = new BasicMessageRepository();

              Object identityNames = getIdentityNames(result, sysConfig);
              String emailTemplate = getEmailTemplate(result, sysConfig);
              List recipients = getEmailRecipient(identityNames, context);

              if (recipients != null &amp;&amp; !Util.isEmpty(recipients)) {
                    // Send Email
                   sendEmailOnTaskCompletion(emailTemplate, recipients, result, context);
              }
              else {
                  if(log.isWarnEnabled()) {
                      log.warn("From Task Completion Email Rule: Cannot send task completion email Notification. Reason : Missing Email Address for Email Recipients");
                  }
              }
          }
    
    </Source>
  </Rule>
  <Rule created="1387809647533" id="c0a8010480751c5d818075ad18f702a5" language="beanshell" modified="1662117621521" name="CEFTransformRule" type="ActivityTransformer">
    <Description>ActivityTransformation Rules are used by the LogFileCollector to transform fields parsed from a text file into our ApplicationActivity model.</Description>
    <Signature returnType="String">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="action">
          <Description>
          The field named action, which is the raw parsed.
          action field.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="mappedAction">
          <Description>
          A normalized ApplicationActivity.Action object.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import sailpoint.object.ApplicationActivity.Action;
import sailpoint.object.ApplicationActivity.Result;
import java.text.SimpleDateFormat;
import java.io;
import sailpoint.object.Configuration;
import java.util.List;

activity.setAction(Action.Grant);
activity.setResult(Result.Success);

//Dump out all params from CEF log entry to console
//System.out.println("CEFTransformRule: In rule");        
//System.out.println("CEFTransformRule: Timestamp=" +cef_timestamp);
//System.out.println("CEFTransformRule: Host=" +cef_host);
//System.out.println("CEFTransformRule: CEFVersion=" + cef_cefversion);
//System.out.println("CEFTransformRule: Vendor=" + cef_vendor);
//System.out.println("CEFTransformRule: Product=" + cef_product);
//System.out.println("CEFTransformRule: Version=" + cef_version);
//System.out.println("CEFTransformRule: Signature=" + cef_signature);
//System.out.println("CEFTransformRule: Name=" + cef_name);
//System.out.println("CEFTransformRule: Severity=" + cef_severity);
//System.out.println("CEFTransformRule: Explanation=" + cef_explanation);

//Find the user parameter in CEF Explanation field
//System.out.println("CEFTransformRule: Breaking down the parameter list.....:");

Object o= Configuration.getSystemConfig().getList(Configuration.ATT_CEF_USER_NAME);
List cefUserNames = null;
if (o instanceof List) {
            cefUserNames = (List)o;
}

for (String paramPair: cef_explanation.split("\\s(?=\\S*(?&lt;!\\\\)=)", 0)){
//	System.out.println("CEFTransformRule: Parameter pair found " + paramPair);
    for(String cefUser: cefUserNames){
        String cefUserParam = cefUser.concat("=.*");
        if (paramPair.matches(cefUserParam)) {
            cef_user = paramPair.split("=",2)[1];
//            System.out.println("CEFTransformRule: duser parameter found! " + cef_user);
        }
    }   
}

// Set activity values
activity.setUser(cef_user);
activity.setAction(Action.Login);
activity.setResult(Result.Success);
activity.setInfo("vendor=" + cef_vendor + " host=" + cef_host + " " + cef_explanation + " severity=" + cef_severity + " product=" + cef_product);
activity.setTarget(cef_name);

// Set timestamp from CEF header, but add current year as this is not supplied
SimpleDateFormat f = new SimpleDateFormat("MMM dd hh:mm:ss yyyy");
defaultYear = Calendar.getInstance().get(Calendar.YEAR);
Date date = date = f.parse(cef_timestamp + " " + defaultYear);
activity.setTimeStamp(date);

return activity;</Source>
  </Rule>
  <Rule created="1388673847625" id="c0a8010480751c5d818075ad199102a6" language="beanshell" modified="1662117621670" name="CEFActivityCorrelation" type="ActivityCorrelation">
    <Description>Rule to show how an CEF activity might be correlated back to an identity. In most cases, this rule will be providing enought information to the correlator so that it can find the Application link. In some cases, it might also be desireable to return something that points back to an Identity, which is also supported.</Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The application where the activity was generated.
          An application may have more then one data source.
        </Description>
        </Argument>
        <Argument name="datasource">
          <Description>
          The data source that returned the activity.
        </Description>
        </Argument>
        <Argument name="activity">
          <Description>
          The activity object that was normalized by
          the data source and that we are trying to
          correlate back to one of our Identities.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="linkIdentity">
          <Description>
          A string that represents the link's identity attribute.
        </Description>
        </Argument>
        <Argument name="linkName">
          <Description>
          A string that represents the link's displayName attribute.
        </Description>
        </Argument>
        <Argument name="linkAttributeName">
          <Description>
          A string that represents the NAME of an attribute that
          can be used to find the Link that maps back to this
          activity.  This attribute must also be supplied
          with the linkAttributeValue variable.
        </Description>
        </Argument>
        <Argument name="linkAttributeValue">
          <Description>
          A string that represents the VALUE of an attribute that
          can be used to find the Link that maps back to this
          activity. This attribute must also be supplied
          with the linkAttributeName variable.
        </Description>
        </Argument>
        <Argument name="identityName">
          <Description>
          The name of an Identity object.
        </Description>
        </Argument>
        <Argument name="identity">
          <Description>
          A fully resolved Identity object in case the rule wants
          to do its own queries to locate the identity.
        </Description>
        </Argument>
        <Argument name="identityAttributeName">
          <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
        </Argument>
        <Argument name="identityAttributeValue">
          <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import sailpoint.object.ApplicationActivity;
  import sailpoint.object.Configuration;
	
//  System.out.println("CEFActivityCorrelation: In Correlation Rule");

    Map returnMap = new HashMap();
    String user = activity.getUser();
	String cefLinkAttributeName = Configuration.getSystemConfig().getString(Configuration.ATT_CEF_LINK_ATTRIBUTE_NAME);
	
    if ( user != null ) {
//		System.out.println("CEFActivityCorrelation: Matching for user " + user);
        returnMap.put("linkAttributeName", cefLinkAttributeName);
        returnMap.put("linkAttributeValue", user);
//        System.out.println("returnMap " + returnMap);
    }

    return returnMap;</Source>
  </Rule>
  <Rule created="1651241720386" id="c0a8010480751c5d818075ad1a4202a7" language="beanshell" modified="1662117621907" name="Application Builder">
    <Description>
    A rule to build and manipulate IdentityIQ application in a bulk.
    All duties are mentioned below.
    1. When create mode is selected, then it creates multiple application in a bulk by parsing csv file.
    2. When update mode is selected, then it updates the attribute map of existing application by parsing input csv file.
    3. When read mode is selected, then it reads all existing IdentityIQ application and export them to csv file.
       Exports considers only attributes of the application.
  </Description>
    <Signature returnType="TaskResult">
      <Inputs>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to save application object and task definitions.
        </Description>
        </Argument>
        <Argument name="log">
          <Description>
          The log object for logging.
        </Description>
        </Argument>
        <Argument name="inputParams">
          <Description>
          The input params object is map of attributes received from Task UI.
        </Description>
        </Argument>
        <Argument name="taskResult">
          <Description>
          The task result object required for updating the result.
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>
    
      import java.io.BufferedReader;
      import java.io.FileNotFoundException;
      import java.io.FileReader;
      import java.io.FileWriter;
      import java.io.IOException;
      import java.util.ArrayList;
      import java.util.Date;
      import java.util.HashMap;
      import java.util.LinkedHashMap;
      import java.util.List;
      import java.util.Map;
      import java.util.Set;
      import java.util.Iterator;
      import java.util.LinkedHashMap;
      import java.util.LinkedHashSet;
      import sailpoint.api.SailPointContext;
      import sailpoint.api.TaskManager;
      import sailpoint.connector.Connector;
      import sailpoint.connector.ConnectorFactory;
      import sailpoint.connector.DefaultApplicationFactory;
      import sailpoint.object.Application;
      import sailpoint.object.Attributes;
      import sailpoint.object.Identity;
      import sailpoint.object.Rule;
      import sailpoint.object.TaskDefinition;
      import sailpoint.object.TaskItemDefinition;
      import sailpoint.object.TaskSchedule;
      import sailpoint.object.TaskResult;
      import sailpoint.object.Filter;
      import sailpoint.object.QueryOptions;
      import sailpoint.object.Attributes;
      import sailpoint.object.AttributeDefinition;
      import sailpoint.object.Attributes;
      import sailpoint.object.Field;
      import sailpoint.object.Form;
      import sailpoint.object.Form.Section;
      import sailpoint.object.FormItem;
      import sailpoint.object.Schema;
      import sailpoint.tools.GeneralException;
      import sailpoint.tools.Message;
      import sailpoint.tools.Util;
      import sailpoint.tools.RFC4180LineIterator;
      import sailpoint.tools.RFC4180LineParser;
      import sailpoint.tools.Rfc4180CsvBuilder;
      import sailpoint.tools.Util;
      import sailpoint.tools.xml.XMLObjectFactory;

      // Private member variables
      private int applicationsCreated = 0;
      private int applicationsUpdated = 0;
      private int applicationsScanned = 0;
      private List applicationsExists = new ArrayList();
      private List applicationsNotFound = new ArrayList();
      private List applicationsFailed = new ArrayList();
      private List applicationObjects = new ArrayList();
      Map applicationMap = new LinkedHashMap();
      Set uniqueHeaders = new LinkedHashSet();

      // Private Input parameters
      private String filePath;
      private String applicationType;
      private String operation;
      private boolean triggerAccountAggregation;
      private boolean triggerGroupAggregation;
      private boolean skipTestConnection;
      private String launcher;
      private int applicationsPerAggregation = 10;

      // Public member variables
      /**
      * List of secret attributes used in different connector's application attribute.
      */
      Set secreteAttributes = new LinkedHashSet();
      String rowSeparator = "\n";
      private String docTypeHeader = "&lt;?xml version='1.0' encoding='UTF-8'?>" +
                             "\n&lt;!DOCTYPE Application PUBLIC \"sailpoint.dtd\" \"sailpoint.dtd\">" +
                             "\n&lt;Application>\n";
      private String docTypeFooter = "\n&lt;/Application>";
      private String schemasHeader = "Schemas";
      private String provisioningFormsHeader = "ProvisioningForms";
      private String create = "create";
      private String update = "update";
      private String read = "read";

      /////////// public methods for processing IdentityIQ applications. ///////////
      //////////////////////////////////////////////////////////////////////////////

      /**
       * Parse the input CSV file based on fix format.
       * and convert it to the attribute map for further processing.
       */
      public void parseInputFile() {
          log.debug("Entering parseInputFile()...");

          BufferedReader br = null;

          try {

              List fileHeaders = new ArrayList();
              Map attributeMap = null;
              br = new BufferedReader(new FileReader(filePath));

              RFC4180LineParser parser = new RFC4180LineParser(",");
              RFC4180LineIterator iterator = new RFC4180LineIterator(br);

              String fileRow = iterator.readLine();

              // Parse file headers
              if (Util.isNotNullOrEmpty(fileRow)) {
                  log.debug("File headers: " + fileRow);

                  fileHeaders = Util.csvToList(fileRow);
              } else {
                  throw new GeneralException("Headers not found. File's first line should be headers.");
              }
              // Parse CSV file data
              while ((fileRow = iterator.readLine()) != null) {
                  List fileRowList = Util.csvToList(fileRow);
                  attributeMap = new HashMap();
                  boolean isApplicationName = true;
                  String applicationName = "";

                  if (fileRowList != null) {
                      if (fileRowList.size() > fileHeaders.size()) {
                          throw new GeneralException("Mismach in row data and headers length. Affected row: " + fileRow);
                      }
                      // Attribute Map received from input file
                      for (int i = 0; i &lt; fileRowList.size(); i++) {
                          String fileRowData = (String)fileRowList.get(i);
                          if (Util.isNotNullOrEmpty(fileRowData)) {
                              if (isApplicationName) {
                                   applicationName = fileRowData;
                                   isApplicationName = false;
                              } else {
                                  if (fileRowData.equalsIgnoreCase("true") || fileRowData.equalsIgnoreCase("false")) {
                                      attributeMap.put(fileHeaders.get(i), Boolean.parseBoolean(fileRowData));
                                  } else {
                                      attributeMap.put(fileHeaders.get(i), fileRowData);
                                  }
                              }
                          }
                      }

                      if (Util.isNotNullOrEmpty(applicationName)) {
                         applicationMap.put(applicationName, attributeMap);
                      }
                  }
              }
          } catch (FileNotFoundException e) {
              throw new GeneralException("File parsing failed. " + e.getMessage(), e);
          } catch (IOException e) {
              throw new GeneralException("File parsing failed. " + e.getMessage(), e);
          } finally {
              try {
                  if (br != null) {
                      br.close();
                  }
              } catch (Exception ex) {
                  log.warn("Error while closing BufferedReader object. " + ex.getMessage);
              }
          }

          log.debug("Exiting parseInputFile()...");
      }

      /**
       * Create multiple IdentityIQ applications based on input application data.
       */
      private void createApplications() {
          log.debug("Entering createApplications()...");

          List aggregationappList = new ArrayList();

          for (Map.Entry entry : applicationMap.entrySet()) {
              String applicationName = (String) entry.getKey();
              Application application = context.getObjectByName(Application.class, applicationName);
              if (application != null) {
                  log.warn("The application '" + applicationName +"' already exists on the IdentityIQ server.");

                  applicationsExists.add(applicationName);
                  continue;
              }

              // Create new IdentityIQ application
              log.debug("Creating the application: " + applicationName);

              application = DefaultApplicationFactory.getDefaultApplicationByTemplate(applicationType);
              application.setCreated(new Date());
              application.setModified(new Date());
              application.setName(entry.getKey());
              application.setAuthoritative(false);
              application.setCaseInsensitive(true);
              application.setIcon("enterpriseIcon");
              application.setOwner(context.getObjectByName(Identity.class, launcher));

              try {
                  createOrUpdateApplications(entry, application, aggregationappList);
              } catch (Exception ex) {
                  applicationsFailed.add(application.getName());
                  log.error("Failed to create the application '" + applicationName + "'. " + ex.getMessage(), ex);

                  continue;
              }
          }

          // Perform account and group aggregation for remianing applications
          if (!aggregationappList.isEmpty()) {
              triggerAggregation(aggregationappList);
          }

          updateTaskResult();

          log.debug("Exiting createApplications()...");
      }

      /**
       * Update multiple IdentityIQ applications based on input application data.
       */
      private void updateApplications() {
          log.debug("Entering updateApplications()...");

          List aggregationappList = new ArrayList();

          for (Map.Entry entry : applicationMap.entrySet()) {
              String applicationName = (String) entry.getKey();
              Application application = context.getObjectByName(Application.class, applicationName);
              if (application == null) {
                  log.warn("The application '" + applicationName + "' is not found.");

                  applicationsNotFound.add(applicationName);
                  continue;
              }

              // Update existing IdentityIQ application
              log.debug("Updating the application: " + applicationName);

              try {
                  createOrUpdateApplications(entry, application, aggregationappList);
              } catch (Exception ex) {
                  applicationsFailed.add(application.getName());
                  log.error("Failed to update the application '" + applicationName + "'. " + ex.getMessage(), ex);

                  continue;
              }
          }

          // Perform account and group aggregation for remianing applications
          if (!aggregationappList.isEmpty()) {
              triggerAggregation(aggregationappList);
          }

          updateTaskResult();

          log.debug("Exiting updateApplications()...");
      }

      /**
       * Retriving the application object from IdentityIQ database for given application type and
       * updating the applicationMap which will be exported to csv file.
       */
      public void updateAttributesMap() {
          log.debug("Entering updateAttributesMap()...");

          Map attributeMap = null;
          boolean encryptedAttrFound = false;

          // Query filter to get list of applications for the specified application type
          Filter filter = Filter.eq("type", applicationType);

          // List of application objects
          List applicationsObjectList = context.getObjects(Application.class, new QueryOptions().addFilter(filter));

          log.debug("Total number of applications of type '" + applicationType + "' are: " + applicationsObjectList.size());

          for (Application application : applicationsObjectList) {
              try {
                  log.debug("Application name: " + application.getName());

                  uniqueHeaders.add("Name");
                  attributeMap = new HashMap();
                  applicationMap.put(application.getName(), attributeMap);
                  attributeMap.put("Name", application.getName());
                  Attributes attrMap = application.getAttributes();

                  // Update encrypted attribute
                  if (!encryptedAttrFound) {
                      if (attrMap.get("encrypted") != null) {
                          List encryptedAttrs = Util.csvToList(attrMap.get("encrypted").toString());
                          secreteAttributes.addAll(encryptedAttrs);
                          encryptedAttrFound = true;
                      }
                  }

                  for (Map.Entry entry : attrMap.entrySet()) {
                      if (entry.getValue() != null) {
                          if (entry.getValue() instanceof String || entry.getValue() instanceof Boolean) {

                              // Update attribute map with key and value
                              attributeMap.put(entry.getKey().toString(), entry.getValue());

                              // Update header set
                              uniqueHeaders.add(entry.getKey().toString());
                          }
                      }
                  }

                  String appXML = application.toXml(false);

                  String schemasHeaderTag = "&lt;Schemas>";
                  String schemasFooterTag = "&lt;/Schemas>";
                  if (appXML.indexOf(schemasHeaderTag) > 0) {
                      String schema = appXML.substring(appXML.indexOf(schemasHeaderTag), appXML.indexOf(schemasFooterTag) + 10);
                      uniqueHeaders.add(schemasHeader);
                      attributeMap.put(schemasHeader, schema);
                  }

                  String provisioningFormsHeaderTag = "&lt;ProvisioningForms>";
                  String provisioningFormsFooterTag = "&lt;/ProvisioningForms>";
                  if (appXML.indexOf(provisioningFormsHeaderTag) > 0) {
                      String forms = appXML.substring(appXML.indexOf(provisioningFormsHeaderTag), appXML.indexOf(provisioningFormsFooterTag) + 20);
                      uniqueHeaders.add(provisioningFormsHeader);
                      attributeMap.put(provisioningFormsHeader, forms);
                  }
              } catch (Exception e) {
                  log.warn("Failed to read application: " + application.getName() + ". " + e.getMessage(), e);
              }
          }

          log.debug("Exiting updateAttributesMap()...");
      }

      /**
      * Export Applications attribute map in csv format.
      */
      public void exportApplications() {
          log.debug("Entering exportApplications()...");

          FileWriter fileWriter = null;

          if (Util.isEmpty(applicationMap)) {
              log.warn("Application '" + applicationType + "' not found on the IdentityIQ server.");

              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);
              taskResult.setAttribute("applicationsScanned", applicationMap.size());
          } else {
              // Perform the file operation when application map is non empty.
              try {
                  log.debug("Application map size: " + applicationMap.size());

                  Rfc4180CsvBuilder csvBuilder = new Rfc4180CsvBuilder();
                  List headers = new ArrayList(uniqueHeaders);

                  // Make sure Schemas column and/or ProvisioningForms placed after configuration attributes
                  if (headers.contains(schemasHeader)) {
                     headers.remove(schemasHeader);
                     headers.add(schemasHeader);
                  }

                  if (headers.contains(provisioningFormsHeader)) {
                     headers.remove(provisioningFormsHeader);
                     headers.add(provisioningFormsHeader);
                  }

                  fileWriter = new FileWriter(filePath);
                  fileWriter.append(Util.listToCsv(headers));
                  fileWriter.append(rowSeparator);

                  for (Map.Entry entry : applicationMap.entrySet()) {
                      StringBuffer attributeRow = new StringBuffer();
                      Map innerAttrMap = (Map) entry.getValue();
                      for (String headerName : headers) {
                          String attrValue = (innerAttrMap.get(headerName) != null) ? innerAttrMap.get(headerName).toString() : "";

                          if (secreteAttributes.contains(headerName)) {
                              attrValue = "";
                          }

                          csvBuilder.addValue(attrValue);
                      }

                      // Update File Row
                      fileWriter.append(csvBuilder.build());

                      fileWriter.append(rowSeparator);
                      csvBuilder.flush();
                  }
              } catch (Exception e) {
                  throw new GeneralException("Failed to export the application attributes map to a file. " + e.getMessage(), e);
              } finally {
                  try {
                      if (fileWriter != null) {
                          fileWriter.flush();
                          fileWriter.close();
                      }
                  } catch (Exception ex) {
                      log.warn("Error while closing fileWriter object. " + ex.getMessage);
                  }
              }

              updateTaskResult();
          }

          log.debug("Exiting exportApplications()...");
       }

      /**
       * Run Account aggregation task for the multiple IdentityIQ applications
       * @param applicationNames comma saperated application names
       *
       */
      private void executeAccountAggregation(String applicationNames) throws GeneralException {
          log.debug("Entering executeAccountAggregation()...");

          TaskManager tm = new TaskManager(context);
          HashMap taskArgs = new HashMap();
          TaskDefinition taskDefinition = new TaskDefinition();
          taskDefinition.setName(applicationType + " Account Aggregation " + new Date() + " - " + Util.rand(1, 10000));
          taskDefinition.setDescription("Account Aggregation task for " + applicationType);
          taskDefinition.setType(TaskItemDefinition.Type.AccountAggregation);
          taskDefinition.setResultAction(TaskDefinition.ResultAction.Delete);
          taskDefinition.setFormPath("/monitor/tasks/accountAggregationTask.xhtml");
          taskDefinition.setArgument("applications", applicationNames);
          taskDefinition.setArgument("checkDeleted", "true");
          taskDefinition.setArgument("promoteManagedAttributes", "true");
          taskDefinition.setArgument("logAllowedActions", null);
          taskDefinition.setOwner(context.getObjectByName(Identity.class, launcher));
          taskDefinition.setParent(context.getObject(TaskDefinition.class, "Account Aggregation"));
          context.saveObject(taskDefinition);
          context.commitTransaction();
          tm.run(taskDefinition, taskArgs);

          log.debug("Account aggregation task is executed for the application '" + applicationNames + "'.");
          log.debug("Exiting executeAccountAggregation()...");
      }

      /**
       * Run Group aggregation task for the multiple IdentityIQ applications
       * applicationNames comma saperated application names
      */
      private void executeGroupAggregation(String applicationNames) throws GeneralException {
          log.debug("Entering executeGroupAggregation()...");

          TaskManager tm = new TaskManager(context);
          HashMap taskArgs = new HashMap();
          TaskDefinition taskDefinition = new TaskDefinition();
          taskDefinition.setName(applicationType + " Group Aggregation " + new Date() + " - " + Util.rand(1, 10000));
          taskDefinition.setDescription("Group Aggregation task for " + applicationType);
          taskDefinition.setType(TaskItemDefinition.Type.AccountGroupAggregation);
          taskDefinition.setArgument("aggregationType", "group");
          taskDefinition.setFormPath("/monitor/tasks/accountGroupAggregationTask.xhtml");
          taskDefinition.setArgument("applications", applicationNames);
          taskDefinition.setArgument("checkDeleted", "true");
          taskDefinition.setOwner(context.getObjectByName(Identity.class, launcher));
          taskDefinition.setExecutor("sailpoint.task.ResourceIdentityScan");
          taskDefinition.setResultRenderer("accountGroupAggregationResult.xhtml");
          taskDefinition.setParent(context.getObject(TaskDefinition.class, "Account Group Aggregation"));
          context.saveObject(taskDefinition);
          context.commitTransaction();
          tm.run(taskDefinition, taskArgs);

          log.debug("Group aggregation task is executed for the application '" + applicationNames + "'.");
          log.debug("Exiting executeGroupAggregation()...");

      }

      /**
       * Create/Update multiple IdentityIQ application from the provided csv file.
       * Also ability to trigger test connection and aggregation based on user input.
       * User can provide schema and provisioning form while create and/or update.
       * The schema merge can be partial or full update.
       * The provisioning forms is full update. i.e it will set whatever forms provided in csv file. 
       */
      private void createOrUpdateApplications(Map.Entry entry, Application application, List aggregationappList) {
          log.debug("Entering createOrUpdateApplications()...");

          Map innerMap = (Map) entry.getValue();
          String applicationName = application.getName();

          for (Map.Entry entryMap : innerMap.entrySet()) {
              String key = (String)entryMap.getKey();
              Object value = entryMap.getValue();

              if (key != null &amp;&amp; !applicationObjects.contains(key) &amp;&amp; value != null) {
                  application.setAttribute((String)entryMap.getKey(), entryMap.getValue());
              }

              if (applicationObjects.contains(key) &amp;&amp; schemasHeader.equals(key)) {
                  mergeSchemas(application, value.toString());
              }

              if (applicationObjects.contains(key) &amp;&amp; provisioningFormsHeader.equals(key)) {
                  setProvisioningForms(application, value.toString());
              }
          }

          // Skip the test connection if the flag is true
          if (!skipTestConnection) {
                Connector conn = ConnectorFactory.getConnector(application, null);
                conn.testConfiguration();
                log.debug("Test connection is successful for the application: " + applicationName);
          } else {
             log.debug("Skipping Test connection for the application: " + applicationName);
          }

          context.saveObject(application);
          context.commitTransaction();

          if (create.equals(operation)) {
              applicationsCreated++;
              log.debug("Created the application: " + applicationName);
          } else if (update.equals(operation)) {
              applicationsUpdated++;
              log.debug("Updated the application: " + applicationName);
          }

          aggregationappList.add(application.getName());

          // Perform account and group aggregation task for configured applications per aggregation
          if (aggregationappList.size() >= applicationsPerAggregation) {
                triggerAggregation(aggregationappList);

                // clear the list for the next chunk of aggregations
                aggregationappList.clear();
          }

          log.debug("Exiting createOrUpdateApplications()...");
      }

      /**
       * Merge schema attribute definitions to specific schema.
       */
      private void mergeSchemas(Application app, String value) {
          log.debug("Entering mergeSchemas() for: " + app.getName());

          if (value != null) {
              String schemas = docTypeHeader + value + docTypeFooter;

              try {
                  Application tempApp = (Application)XMLObjectFactory.getInstance().parseXml(context, schemas, true);
                  List tempAppSchemas = tempApp.getSchemas();
    
                  for (Schema tempSchema : tempAppSchemas) {
                      Schema orgAppSchema = app.getSchema(tempSchema.getObjectType());
    
                      // Found schema, add the new attribute
                      if (orgAppSchema != null) {
                          List tempAttributes = tempSchema.getAttributes();
                          List orgAttributes = orgAppSchema.getAttributes();
                          List orgAttributesNames = orgAppSchema.getAttributeNames();

                          if (tempSchema.getIdentityAttribute() != null) {
                              orgAppSchema.setIdentityAttribute(tempSchema.getIdentityAttribute());
                          }

                          if (tempSchema.getDisplayAttribute() != null) {
                              orgAppSchema.setDisplayAttribute(tempSchema.getDisplayAttribute());
                          }

                          if (tempSchema.getInstanceAttribute() != null) {
                              orgAppSchema.setInstanceAttribute(tempSchema.getInstanceAttribute());
                          }
    
                          for (AttributeDefinition tempAttribute : tempAttributes) {
                              if (orgAttributesNames.contains(tempAttribute.getName())) {
                                  log.debug("Found Schema attribute: '" + tempAttribute.getName() + "'.");

                                  // Attribute Definition found, remove it first.
                                  int index = orgAttributesNames.indexOf(tempAttribute.getName());
                                  orgAttributes.remove(orgAttributesNames.indexOf(tempAttribute.getName()));
                                  log.debug("Removed Schema attribute: '" + tempAttribute.getName() + "'.");

                                  // Add attribute to specific index
                                  orgAttributes.add(index, tempAttribute);
                                  log.debug("Added Schema attribute: '" + tempAttribute.getName() + "'.");
                              } else {
                                  // Add attribute, as it not present in original schema
                                  orgAttributes.add(tempAttribute);
                                  log.debug("Added Schema attribute: '" + tempAttribute.getName() + "'.");
                              }
                          }
                      } else { 
                          // add new schema
                          // cleaning id, created, modified schema attributes for the new schema if they exists.
                          // ideally new schema should not have those attributes.
                          if (tempSchema.getId() != null) {
                              tempSchema.setId(null);
                          }
                          if (tempSchema.getId() != null) {
                              tempSchema.setId(null);
                          }
                          if (tempSchema.getCreated() != null) {
                              tempSchema.setCreated(null);
                          }
                          if (tempSchema.getModified() != null) {
                              tempSchema.setModified(null);
                          }

                          app.setSchema(tempSchema);
                      }
                  }
              } catch (Exception e) {
                  String message = "Failed to merge Schema for the application: '" + app.getName() + "'.";
                  log.error(message, e);
                  throw new GeneralException(message, e);
              }
          }

          log.debug("Exiting mergeSchemas()...");
      }

      /**
       * Sets Provisioning forms to the application based on user input.
       * It is full update. i.e Application will set provisioning forms defined in the csv file.
       */
      private void setProvisioningForms(Application app, String value) {
          log.debug("Entering setProvisioningForms() for: " + app.getName());

          if (value != null) {
              String provisioningForms = docTypeHeader + value + docTypeFooter;
              try {
                  Application tempApp = (Application)XMLObjectFactory.getInstance().parseXml(context, provisioningForms, true);
                  List tempAppProvisioningForms = tempApp.getProvisioningForms();
    
                  if (tempAppProvisioningForms != null) {
                      app.setProvisioningForms(tempAppProvisioningForms);
                  }
              } catch (Exception e) {
                  String message = "Failed to set Provisioning Forms for the application: '" + app.getName() + "'.";
                  log.error(message, e);
                  throw new GeneralException(message, e);
              }
          }

          log.debug("Exiting setProvisioningForms()...");
      }

      /**
       * Trigger aggregation.
       */
      private void triggerAggregation(List aggregationappList) {
          String appsToaggregate = Util.listToCsv(aggregationappList);
          // Trigger account aggregation
          if (triggerAccountAggregation) {
              executeAccountAggregation(appsToaggregate);
          }

          // Trigger group aggregation
          if (triggerGroupAggregation) {
              executeGroupAggregation(appsToaggregate);
          }
      }

      /**
       * Update task result of Create/Update Applications.
       */
      private void updateTaskResult() {
          log.debug("Entering updateTaskResult()...");

          if (applicationsFailed.size() > 0) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);
              if (create.equals(operation)) {
                  taskResult.addMessage(Message.error("application_builder_create_failed_error", applicationsFailed.size()));
              } else if (update.equals(operation)) {
                  taskResult.addMessage(Message.error("application_builder_update_failed_error", applicationsFailed.size()));
              }
          } else if (applicationsExists.size() > 0) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Warning);
              taskResult.addMessage(Message.warn("application_builder_create_warning_msg", filePath));
          } else if (applicationsNotFound.size() > 0) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Warning);
              taskResult.addMessage(Message.warn("application_builder_update_warning_msg", filePath));
          } else {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);
          }

          if (create.equals(operation)) {
              taskResult.setInt("applicationsCreated", applicationsCreated);
              taskResult.setAttribute("applicationsExists", Util.listToCsv(applicationsExists));
          } else if (update.equals(operation)) {
              taskResult.setInt("applicationsUpdated", applicationsUpdated);
              taskResult.setAttribute("applicationsNotFound", Util.listToCsv(applicationsNotFound));
          } else if (read.equals(operation)) {
              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);
              taskResult.setAttribute("applicationsScanned", applicationMap.size());
              taskResult.setAttribute("exportFilePath", filePath);
          }

          taskResult.setAttribute("applicationsFailed", Util.listToCsv(applicationsFailed));
          log.debug("Exiting updateTaskResult()...");
      }

      /////////////////// MAIN START /////////////////
      ////////////////////////////////////////////////


      log.debug("Application Builder Rule execution start...");

      try {
          // Retriving input parameters
          filePath = inputParams.get("filePath");
          applicationType = inputParams.get("applicationType");
          operation = inputParams.get("operation");
          triggerAccountAggregation = inputParams.get("triggerAccountAggregation");
          triggerGroupAggregation = inputParams.get("triggerGroupAggregation");
          launcher = inputParams.get("launcher");
          skipTestConnection = inputParams.get("skipTestConnection");

          if (!(filePath.trim().endsWith(".csv") || filePath.trim().endsWith(".CSV"))) {
              throw new GeneralException("Invalid input file format '" + filePath + "'. Only CSV format is supported.");
          }

          if (inputParams.get("applicationsPerAggregation") != null) {
              try {
                  if (Integer.parseInt(inputParams.get("applicationsPerAggregation")) > 0) {
                      applicationsPerAggregation = Integer.parseInt(inputParams.get("applicationsPerAggregation"));
                  }
              } catch (NumberFormatException e) {
                  log.warn("Invalid value for the attribute 'applicationsPerAggregation'. " + e.getMessage() + ". Considering default value " + applicationsPerAggregation , e);
              }
          }

          // Update Secrete attribute list as per sailpoint.object.Application
          secreteAttributes.add("password");
          secreteAttributes.add("cmdClientPassword");
          secreteAttributes.add("adminPassword");
          secreteAttributes.add("apikey");
          secreteAttributes.add("kid");
          secreteAttributes.add("secret");
          secreteAttributes.add("keystorePwd");
          secreteAttributes.add("token");
          secreteAttributes.add("transportUserPassword");
          secreteAttributes.add("group.password");
          secreteAttributes.add("accountId");
          secreteAttributes.add("keystorepassword");
          secreteAttributes.add("pkeypassword");
          secreteAttributes.add("admin_password");
          secreteAttributes.add("SudoUserPassword");
          secreteAttributes.add("PassphraseForPrivateKey");
          secreteAttributes.add("passwd");

          // Add application objects to list, special handling for merge is required.
          applicationObjects.add(schemasHeader);
          applicationObjects.add(provisioningFormsHeader);

          // Perform Task based on operation type
          switch (operation) {
              case create:
                  parseInputFile();
                  createApplications();
                  break;
              case update:
                  parseInputFile();
                  updateApplications();
                  break;
              case read:
                  updateAttributesMap();
                  exportApplications();
                  break;
              default:
                  log.debug("Invalid Operation.");
                  break;
          }
      } catch (GeneralException e) {
          log.error(Message.error("application_builder_task_error", e.getMessage()), e);

          // Update taskResult object with error details
          taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);
          taskResult.addMessage(Message.error("application_builder_task_error", e.getMessage()));
      } catch (Exception e) {
          GeneralException ex = new GeneralException(Message.error("application_builder_task_error", e.getMessage()), e);
          log.error(ex.getMessage(), ex);

          // Update taskResult object with error details
          taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);
          taskResult.addMessage(Message.error("application_builder_task_error", e.getMessage()));
      }

      return taskResult;
    
  </Source>
  </Rule>
  <Rule created="1655803592163" id="c0a80c01817f175d81818595bde203d0" language="beanshell" modified="1657517881103" name="R1-Get Reportess For Manager" type="Validation">
    <Source>  
  import sailpoint.object.*;
  import sailpoint.api.*;
  import sailpoint.api.SailpointContext;  
  import sailpoint.object.Identity;  
  import sailpoint.object.Filter;
  import sailpoint.object.QueryOptions; 
  import sailpoint.object.Link; 
  import sailpoint.object.ProvisioningPlan;
  import sailpoint.object.ProvisioningPlan.AccountRequest;
  import sailpoint.object.ProvisioningPlan.AttributeRequest;
  
  import oracle.jdbc.OracleTypes;
  
  import java.util.*;  
  import java.io;
  import java.sql.ResultSet;
  import java.sql.Statement;
  import java.sql.Connection;
  import java.sql.DriverManager;
  import java.sql.Types;
  import java.sql.PreparedStatement;
  import java.sql.SQLException;
  import java.sql.Date;
  
  
  List list = new ArrayList();
  List applist = new ArrayList();
  List entllist = new ArrayList();  
  List identityObject =  context.getObjects(Identity.class);
  List appObject =  context.getObjects(Application.class);
  List entlObj =  context.getObjects(IdentityEntitlement.class);
  String  strDispName="";
  String  strDispYName="";  
  for(Identity id : identityObject)
  {  
   list.add(id.getName());
   strDispName= strDispName+"\n Display Name:: "+ id.getDisplayName();
   strDispYName= strDispYName+"\n Email:: "+ id.getFirstname();
  }  
  for(Application apname : appObject)
  {
   applist.add( apname.getName());
  }
  for(IdentityEntitlement entname : entlObj)
  {
   entllist.add( entname.getName());
  }      
  System.out.println("**********"+list);
  System.out.println("**********"+applist);
  System.out.println("**********"+entllist);  
  
  QueryOptions queryOption = new QueryOptions();
  queryOption.addFilter(Filter.eq("name","James Smith"));
  
  Iterator identityIterator = context.search(Identity.class, queryOption);   
  while ( identityIterator.hasNext() ) {  
   System.out.println("identityIterator : in while " );
    Identity id = (Identity) identityIterator.next();  
   System.out.println("id : " + id);
   System.out.println("Name : "+id.getName());  
   System.out.println("Attributes : "+id.getAttributes()); 
   System.out.println("Role Assignments : "+id.getRoleAssignments());
   System.out.println("Links : "+id.getLinks());  
}  
  // QueryOptions appqueryOption = new QueryOptions();
  
    // appqueryOption.addFilter(Filter.eq("application.name","Delimited_HR_Application"));
     //Iterator ApplicationIterator = context.search(Link.class, appqueryOption);     
  
 // while ( ApplicationIterator.hasNext() ) {  
  // System.out.println("ApplicationIterator : in while " );
  // Object[] row = (Object[]) ApplicationIterator.next();

    // String id1 = row[1];
  //  System.out.println("Application : "+id1);  
//}   
  // Return the selected identity
  //Connecting to My sql 
  try{
       String strPeopleqry= "SELECT *  FROM [Test].[dbo].[People]";
       String strGroupqry= "SELECT *  FROM [Test].[dbo].[Group]";
       PreparedStatement statement = connection.prepareStatement(strPeopleqry);
       ResultSet rs = statement.executeQuery(strPeopleqry);
       while (rs.next())
       {
          System.out.println(rs.getString(1));
       }
  } catch (Exception e) {
                               System.out.println("JDBCApplication Create Error e: " +e.getMessage());    
    }finally { 

      try{ 
         if (connection != null) 
     connection.close(); 
      }catch (SQLException e) { 
         e.printStackTrace(); 
              } 
      }      
  
return list;
</Source>
  </Rule>
  <Rule created="1657691782842" id="c0a80c0181d917b08181f6213eba0c97" language="beanshell" modified="1658141389829" name="SetManagerName" type="IdentityAttribute">
    <Description>Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.

This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the "link" argument which is not passed in global mapping rules.</Description>
    <Signature returnType="String">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="environment" type="Map">
          <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
        </Argument>
        <Argument name="identity">
          <Description>
           The Identity object that represents the user
           that is being aggregated.
        </Description>
        </Argument>
        <Argument name="attributeDefinition">
          <Description>
           The AttributeDefinition object for this attribute.
        </Description>
        </Argument>
        <Argument name="link">
          <Description>
           The Link object from the Identity, if this is an application
           mapping rule.  For global mapping rules this will be void.
        </Description>
        </Argument>
        <Argument name="attributeSource">
          <Description>
          The AttributeSource object.
        </Description>
        </Argument>
        <Argument name="oldValue">
          <Description>
          The original value of the application account attribute.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="attributeValue">
          <Description>
          The value of the attribute that should be populated.
          The rule should return this value.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>
import sailpoint.api.SailPointContext;  
import sailpoint.object.Identity;
import sailpoint.object.*; 
import java.util.*;  
import java.io;
import sailpoint.object.Link;
import sailpoint.object.Attributes;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;
  

  Logger log = Logger.getLogger("sailpoint.services.bshdemo");
  log.error("Manager map logger");
  
  String mnagerName= "";
  String mnagerNam1= "";
  String strDispName= "";
  String strDispName= "";
  String strEmpID= "1a";
  String strIdentityEmpID="";
  String strApplication = "";
  List list = new ArrayList();
  List list1 = new ArrayList();
  
  String ssss="";

  List listOfIdentities =  context.getObjects(Identity.class);
  for(Identity id : listOfIdentities)
  {  
    list.add(id.getLinks()); 
    for(Link link: list)
    {
     return link.getApplicationName();
    }
    
  }
    
 
    strIdentityEmpID = id.getAttribute("EmployeeID");
    if(list!=null)
    {
         ssss="\n"+ssss+list.getApplicationName();
    }
    
    //System.out.println(strIdentityEmpID);
    if(strIdentityEmpID != null)
    {
       mnagerName = id.getAttribute("manager");
       mnagerNam1 = mnagerNam1+"Employee :: "+id.getName()+" Manager is -  "+mnagerName+"\n";       
    }
  }  
  
   List listOfAllications =  context.getObjects(Application.class);

   for(Application Apid : listOfAllications)
  {  
    //System.out.println("Inside for");   
    strApplication = strApplication+"\n"+Apid.getName();
    
  }  
  

  return ssss;
  </Source>
  </Rule>
  <Rule created="1657797148653" id="c0a80c0181f8157b8181fc68ffed01fe" language="beanshell" modified="1658213193234" name="R1_BuildMaprule" type="BuildMap">
    <Description>This rule is used by the delimited file connector to build a map representation of the delimited data.</Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The application whose data file is being processed.
        </Description>
        </Argument>
        <Argument name="schema">
          <Description>
          The Schema currently in use.
        </Description>
        </Argument>
        <Argument name="state">
          <Description>
          A Map containing state information.
        </Description>
        </Argument>
        <Argument name="record">
          <Description>
          A List of data tokens parsed from the current line of the data file.
        </Description>
        </Argument>
        <Argument name="cols">
          <Description>
          A List of the columns to use.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="map">
          <Description>
          A Map of the resource object assembled from the data.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import sailpoint.api.SailPointContext;  
import sailpoint.object.Identity;
import sailpoint.object.*; 
import java.util.*;  
import java.io;

System.out.println("Called Build map rule"); 
// Execute default build map logic
Map map = DelimitedFileConnector.defaultBuildMap(cols, record);
System.out.println(map);  
return map ;</Source>
  </Rule>
  <Rule created="1657797453404" id="c0a80c0181f8157b8181fc6da65c020f" language="beanshell" modified="1658213355742" name="R1-MaptoResourceObjRule" type="Transformation">
    <Description>This rule is used by the delimited file connector and will transform a Map into a ResourceObject.</Description>
    <Signature returnType="ResourceObject">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The application being processed.
        </Description>
        </Argument>
        <Argument name="schema">
          <Description>
      The schema being iterated.
        </Description>
        </Argument>
        <Argument name="object">
          <Description>
      A Map representing the data to be transformed.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="resourceObject">
          <Description>
          The resulting ResourceObject.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import sailpoint.api.SailPointContext;  
import sailpoint.object.Identity;
import sailpoint.object.*; 
import java.util.*;  
import java.io;

       System.out.println("Called Map to Resource Object Rule");  
       Map Emp = new HashMap();
  return Emp ;</Source>
  </Rule>
  <Rule created="1657797590813" id="c0a80c0181f8157b8181fc6fbf1b0213" language="beanshell" modified="1658213386187" name="R1-MergeMapRule" type="MergeMaps">
    <Description>This rule merges two maps together. This is used when there are multiple lines that represent the same object, and certain attributes have to merged.</Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The application associated with the Connector calling the rule.
        </Description>
        </Argument>
        <Argument name="schema">
          <Description>
          The Schema from the application.
        </Description>
        </Argument>
        <Argument name="current">
          <Description>
          The current Map object that needs merging.
        </Description>
        </Argument>
        <Argument name="newObject">
          <Description>
          The new Map object that needs merging.
        </Description>
        </Argument>
        <Argument name="mergeAttrs">
          <Description>
          A List of the attributes to merge.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="map">
          <Description>
          A Map of the current and new maps, merged according to the attributes list.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import sailpoint.api.SailPointContext;  
import sailpoint.object.Identity;
import sailpoint.object.*; 
import java.util.*;  
import java.io;

  System.out.println("Called Merge Maps Rule");

Map Emp = new HashMap();


  return Emp ;</Source>
  </Rule>
  <Rule created="1658140675106" id="c0a80c0182101158818210e2cc220023" language="beanshell" modified="1658917143437" name="SetManagerName1" type="Validation">
    <Source>
import sailpoint.api.SailPointContext;  
import sailpoint.object.Identity;
import sailpoint.object.*; 
import java.util.*;  
import java.io;
import sailpoint.object.Link;
import sailpoint.object.Attributes;
import sailpoint.object.ManagedAttribute;
import org.apache.log4j.Logger;
import org.apache.log4j.Level;  

  Logger log = Logger.getLogger("sailpoint.services.bshdemo");
  log.error("Manager map logger");
  
  String mnagerName= "";
  String mnagerNam1= "";
  String strDispName= "";
  String strDispName= "";
  
  String strmngedattName= "";
  String strEmpID= "1a";
  String strIdentityEmpID="";
  String strApplication = "";
  List list = new ArrayList();
  List list1 = new ArrayList();
  List listid = new ArrayList();
  List entlObj = new ArrayList();
  
  String ssss= "";
  
  
  List entlObj =  context.getObjects(ManagedAttribute.class);
  
  for(ManagedAttribute mngatt : entlObj)
  {
   // Application app = mngatt.getApplication();
    System.out.println(mngatt.displayName);
                       //strmngedattName = "    :::::\n"+strmngedattName+mngatt.displayName;    
  }  

  /*List listOfIdentities =  context.getObjects(Identity.class);
  for(Identity id : listOfIdentities)
  {  
    listid.addAll(id.getLinks());
    if(listid!=null)
    {
      for(Link li:listid)
      {
         ssss = ssss+"\n"+id.getName()+" is belongs to Application  "+li.getApplicationName();
      }       
  	}
    strIdentityEmpID = id.getAttribute("EmployeeID");
    if(strIdentityEmpID != null)
    {
       mnagerName = id.getAttribute("manager");
       mnagerNam1 = mnagerNam1+"Employee :: "+id.getName()+" Manager is -  "+mnagerName+"\n";       
    }
  }  
  
   List listOfAllications =  context.getObjects(Application.class);

   for(Application Apid : listOfAllications)
   {
    strApplication = strApplication+"\n"+Apid.getName();    
   }  
  */
  return strmngedattName;  
  </Source>
  </Rule>
  <Rule created="1658205648362" id="c0a80c0182101158818214c235ea0179" language="beanshell" modified="1658205741519" name="R!-MergeMapRule" type="MergeMaps">
    <Description>This rule merges two maps together. This is used when there are multiple lines that represent the same object, and certain attributes have to merged.</Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The application associated with the Connector calling the rule.
        </Description>
        </Argument>
        <Argument name="schema">
          <Description>
          The Schema from the application.
        </Description>
        </Argument>
        <Argument name="current">
          <Description>
          The current Map object that needs merging.
        </Description>
        </Argument>
        <Argument name="newObject">
          <Description>
          The new Map object that needs merging.
        </Description>
        </Argument>
        <Argument name="mergeAttrs">
          <Description>
          A List of the attributes to merge.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="map">
          <Description>
          A Map of the current and new maps, merged according to the attributes list.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import java.util.Map;
import java.util.HashMap;
System.out.println("Called Merge Maps Rule");
Map merged = new HashMap(current);
for ( String attrName : mergeAttrs ) {
 Object currentValue = current.get(attrName);
 Object additionalValue = newObject.get(attrName);
 if ( currentValue != null ) {
 if ( additionalValue != null ) {
 if ( currentValue instanceof List ) {
 if ( additionalValue instanceof List ) {
 // loop through additional values list adding to current
 // value list if not already there 
 for ( Object value : (List)additionalValue ) {
 if (!((List)currentValue).contains(value)) {
 
((List)currentValue).add(value);
 }
 } 
 } else {
 if (!((List)currentValue).contains(additionalValue) ) {
 // Add value to list if not already there
((List)currentValue).add(additionalValue);
 }
 } 
 } else { // currentValue is not list
 // replace attribute with new object value in return map
 merged.put(attrName, additionalValue);
 }
 } 
 } else { // current value is null
 if ( additionalValue != null ) {
 // Add additionalValue as attribute in map
 merged.put(attrName, additionalValue);
 }
 } 
} // end for
return merged;</Source>
  </Rule>
  <Rule created="1658213278369" id="c0a80c018215103481821536a2a1000d" language="beanshell" modified="1659094542999" name="R1-Preiterate" type="PreIterate">
    <Description>This rule is called before the connector processes the data in a file.</Description>
    <Signature returnType="void">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          Application being iterated.
        </Description>
        </Argument>
        <Argument name="schema">
          <Description>
          Schema representing the data being iterated.
        </Description>
        </Argument>
        <Argument name="stats">
          <Description>
          A map passed by the connector of the stats for the file about to be iterated.
          Contains keys:
            fileName : (String) filename of the file about to be processed
            absolutePath : (String) absolute filename
            length : (Long) length in bytes
            lastModified : (Long) last time the file was updated Java GMT
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>
import java.io.IOException;
import java.util.*;
import java.io.File;
import java.io.FileReader;
import java.util.List;
import java.util.stream.Stream;
import java.nio.file;
import java.nio.file.Path;
import java.nio.file.Paths;
  
  import java.io.*;
  import java.io.BufferedReader;
  import java.io.ByteArrayInputStream;
  import java.io.FileReader;
  import java.io.InputStream;
  
String stringFilepath = application.getAttributeValue("file");//Get file path from applivation 
Path path = Paths.get(stringFilepath);
Path fileName = path.getFileName();
String connectorfilename = fileName.toString(); 
String directoryPath = new File(stringFilepath).getParent(); 
StringBuilder strbulider = new StringBuilder();
stringFilepath=directoryPath.replace("\\","\\\\");

File folder = new File(stringFilepath);
   File[] fileNames = folder.listFiles();
  if(fileNames != null){
    for(File file : fileNames){      
      Path path1 = Paths.get(file.toString());
      Path fileName1 = path1.getFileName();
      String fileforName=  fileName1.toString();
      if(fileName1.toString().equals(connectorfilename))
      {
      	//System.out.println("This is connector file::"+file);
        BufferedReader br = new BufferedReader(new FileReader(file.toString()));        
        while ((line = br.readLine()) != null)   
        {  
          strbulider.append(line+"\n");
        }
      }
      else
      {
     String line = "";  
		 String splitBy = "&amp;"; 	
		 String strEmpid="";
		 String strRemFilds="";
		
		Map Emp = new HashMap();
		
		BufferedReader br = new BufferedReader(new FileReader(file.toString()));  
		//List hrdlist = new ArrayList();
		//int intcnt =0;
		//hrdlist.clear();
		//Emp.clear();
		while ((line = br.readLine()) != null)   
		{  
      strbulider.append(line+"\n");
      
			/*String[] employee = line.split(splitBy);  
			if(intcnt==0)
			{			
				hrdlist = Arrays.asList(employee);
			}
			intcnt++;
			List currentRow  = Arrays.asList(employee);
			
			Map eachRowMap = new HashMap();
			for(int i = 0; i >= currentRow.size()-1; i++)
			{
				eachRowMap.put(hrdlist.get(i), currentRow.get(i));				
			}			
		  Emp.put(currentRow.get(0),currentRow);	*/
     
    }
       // System.out.println(strbulider.toString());   
        }
      } 
    
    }
   InputStream isr =  new ByteArrayInputStream(strbulider.toString().getBytes());
   return isr;  
  </Source>
  </Rule>
  <Rule created="1658213325487" id="c0a80c0182151034818215375aad000e" language="beanshell" modified="1664518210651" name="R1_PostIterate" type="PostIterate">
    <Description>This rule is called after the connector processes the data in a file.

Stats is a Map passed in by the connector with the information it has gathered. Custom keys can be added here if necessary for validation.</Description>
    <Signature returnType="void">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          Application being iterated.
        </Description>
        </Argument>
        <Argument name="schema">
          <Description>
          Schema requested during iteration.
        </Description>
        </Argument>
        <Argument name="stats">
          <Description>
          A map of the stats for the current file that was just iterated.
          Contains keys:
            fileName : (String) filename of the file about to be processed
            absolutePath : (String) absolute filename
            length : (Long) length in bytes
            lastModified : (Long) last time the file was updated Java GMT
            columnNames : (List) column names that were used during the iteration
            objectsIterated : (Long) total number of objects iterated during this run
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>
  
import sailpoint.object.*;
import java.time.format.DateTimeFormatter;  
import java.time.LocalDateTime;  
import java.util.*;

System.out.println("Post Iterate called");

String appName =  application.getName();
String curDate = java.time.LocalDate.now().toString();
String custobjName = "DelimtCustObj";// appName +curDate ;
System.out.println("custobjName:::"+custobjName);
//Checking if custom object exist
  Custom custlst = context.getObjectByName( Custom.class, custobjName);
  if(custlst != null)
		{
		System.out.println("The Custon object "+custobjName+"alredy exist");     
    
    //put application values to cust objet
    //custlst.getAttributes().put("Application Name", arappname); 
    List lstapp = (List) custlst.getAttributes().get("Application Name");
    lstapp.add(appName);
    List lstdate = (List) custlst.getAttributes().get("Aggregation Date");
    lstdate.add(curDate);
    context.saveObject(custlst);
    context.commitTransaction();
    //return;			
		}
		else
		{  
      //Create custom object
      System.out.println("The Custon object creating");  
      Custom cust=new Custom();
      cust.setName(custobjName);
      Map m=new HashMap();
      
       ArrayList arappname = new ArrayList();
       appname.add(appName);
      
      ArrayList arcreatedate = new ArrayList();
      arcreatedate.add(curDate);
      
      
      m.put("Application Name", arappname);     
      m.put("Aggregation Date",arcreatedate);  
      
      Attributes strb = new Attributes();
      strb.setMap(m);
      
      cust.setAttributes(strb);  
      
       context.saveObject(cust);
       context.commitTransaction();   
     
      System.out.println("The Custon object created");
    }</Source>
  </Rule>
  <Rule created="1658217363534" id="c0a80c018215103481821574f84d0065" language="beanshell" modified="1658476506758" name="R1_Customization_FLNAmeMegeToDisplayname" type="ResourceObjectCustomization">
    <Description>This rule is configured on the application and is called after the connector has build a ResourceObject from the native application data.

Initially designed for non-rule based connectors to add SPPrivileged flag to an object, but could be used to do any transformations.</Description>
    <Signature returnType="ResourceObject">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="object">
          <Description>
          The ResourceObject built by the connector.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          Application that references the connector.
        </Description>
        </Argument>
        <Argument name="connector">
          <Description>
          The connector object.
        </Description>
        </Argument>
        <Argument name="state">
          <Description>
          A Map containing state information.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="resourceObject">
          <Description>
          The updated resource object.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import java.io.* ;
import java.util.*;
import java.io.BufferedReader;  
import java.io.FileReader;  
import java.io.IOException; 
import sailpoint.object.Identity;
System.out.println("You are in Customization Rule");
String fn=object.get("GivenName");
//System.out.println("First Name:: "+fn);
String ln=object.get("Surname");
//System.out.println("Last Name:: "+ln);
String dispName = fn+" "+ln;
//System.out.println("Display Name :: "+dispName);
object.put("DisplayName",dispName);
String strManagerName = "";
  
List identityObject =  context.getObjects(Identity.class);
  
//System.out.println("Outside for");
/*for(Identity id : identityObject)
{   
  if(id.getAttribute("EmployeeID"=="1a")
  {
     System.out.println("Inside for");
     System.out.println(id.getAttribute("EmployeeID"));
     System.out.println(id.getAttribute("manager"));
     System.out.println("Object ManagerID :: "+object.get("manager"));

     System.out.println("EmployeeID :: "+id.getAttribute("EmployeeID"));
     System.out.println("ManagerID :: "+id.getAttribute("manager"));
     System.out.println("Object ManagerID :: "+object.getAttribute("manager"));
      if(id.getAttribute("EmployeeID") == object.getAttribute("manager"))
      {
      System.out.println("Inside if");
      strManagerName = id.getAttribute("Name");
      }  
  }
 }  
object.put("ManagerName",strManagerName );
*/
return object;</Source>
  </Rule>
  <Rule created="1658475820854" id="c0a80c01822018ca818224dcb73601a7" language="beanshell" modified="1658829901571" name="R1_CorrelationRule" type="Correlation">
    <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="environment" type="Map">
          <Description>
          Arguments passed to the aggregation task.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          Application being aggregated.
        </Description>
        </Argument>
        <Argument name="account">
          <Description>
          A sailpoint.object.ResourceObject returned from the
          collector.
        </Description>
        </Argument>
        <Argument name="link">
          <Description>
          Existing link to this account.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="identityName">
          <Description>
          The name of an Identity object.
        </Description>
        </Argument>
        <Argument name="identity">
          <Description>
          A fully resolved Identity object if the rule wants
          to do its own queries to locate the identity.
        </Description>
        </Argument>
        <Argument name="identityAttributeName">
          <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
        </Argument>
        <Argument name="identityAttributeValue">
          <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>System.out.println("you are in correlation rule");
return map;</Source>
  </Rule>
  <Rule created="1658827254873" id="c0a80c018239142e818239cf2c590040" language="beanshell" modified="1664447373077" name="R1-Managed Entitlement Customization Rule" type="ManagedAttributePromotion">
    <Description>A ManagedAttributePromotion rule is called when ManagedAttributes are automatically created during aggregation, refresh, or from the missing entitlement descriptions task.

This can modify the ManagedAttribute that is passed in to set fields such as owner, requestable, or explanations before they are saved.</Description>
    <Signature>
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="attribute">
          <Description>
          The sailpoint.object.ManagedAttribute to modify during promotion.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The sailpoint.object.Application the managed attribute is from.
        </Description>
        </Argument>
        <Argument name="state" type="Map">
          <Description>
          A Map that contains managed attribute promotion shared state during a task run.
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>import sailpoint.object.*;
import java.util.Locale;

System.out.println("Managed Entitlement Customization Rule");
String appname = application.getName();
String description = "This entitlement belongd to applcation::  "+appname;
System.out.println("description :: "+description );
attribute.addDescription(Locale.US.toString(), description); 
return attribute;</Source>
  </Rule>
  <Rule created="1658898390410" id="c0a80c01823d1f2f81823e0c9d8a0013" language="beanshell" modified="1658906252013" name="R1-ADCustomRule" type="ResourceObjectCustomization">
    <Description>This rule is configured on the application and is called after the connector has build a ResourceObject from the native application data.

Initially designed for non-rule based connectors to add SPPrivileged flag to an object, but could be used to do any transformations.</Description>
    <Signature returnType="ResourceObject">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="object">
          <Description>
          The ResourceObject built by the connector.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          Application that references the connector.
        </Description>
        </Argument>
        <Argument name="connector">
          <Description>
          The connector object.
        </Description>
        </Argument>
        <Argument name="state">
          <Description>
          A Map containing state information.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="resourceObject">
          <Description>
          The updated resource object.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import sailpoint.object.*;
import java.util.*;

List entllist = = new ArrayList();

List entlObj =  context.getObjects(Entitlement.class);

for(Entitlement entname : entlObj)
  {
   entllist.add( entname.getName());
  }   
System.out.println(entllist);

/*System.out.println("You are in AD customozation rule");
System.out.println(object.get("displayName"));

String strUserName = object.get("displayName");
System.out.println("strUserName :: "+object.get("displayName"));
if(strUserName.equalsIgnoreCase("Hudson, Andrea") )
{
System.out.println("Andrea Hudson find in AD and Resouceobject is returned to sailpoint identity creation");
return object;
}
else
{
object=null;
}*/

object=null;

return object;</Source>
  </Rule>
  <Rule created="1658902050827" id="c0a80c01823d1f2f81823e44780b006b" language="beanshell" modified="1663938051726" name="R1-ADBeforeProvisipningRule" type="BeforeProvisioning">
    <Description>An IdentityIQ server-side rule that is executed before the connector's provisioning method is called. This gives the customer the ability to customize or react to anything in the ProvisioningPlan BEFORE it is sent to the underlying connectors used in provisioning. 

This rule will be called for any application found in a plan that also has a configured 'beforeProvisioningRule' configured.  

The plan can be updated directly in the rule by reference and does not need to return the plan.</Description>
    <Signature>
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="plan">
          <Description>
          The ProvisioningPlan object on its way to the Connector.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The application object that references this before/after script.
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>import sailpoint.object.*;
import sailpoint.tools.*;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest; 
import sailpoint.object.ProvisioningPlan.Operation;
import java.util.*;
import sailpoint.tools.*;
import sailpoint.object.Filter;
import sailpoint.object.QueryOptions;
import sailpoint.connector.ConnectorFactory;

System.out.println("AD Before provision Plan Object::\n"+ plan.toXml());</Source>
  </Rule>
  <Rule created="1657691782842" id="c0a870018290142e8182904def100095" language="beanshell" modified="1662699984755" name="CR_ReadCustomObject" type="IdentityAttribute">
    <Description>
    This rule is created to get custom objects usage and return values(email id) and to get mail id from sailpoint IIQ with custom object name.
  </Description>
    <Source>
  import sailpoint.api.SailPointContext; 
  import sailpoint.object.*;
  import sailpoint.api.SailPointFactory;
  import sailpoint.tools.GeneralException;
  import sailpoint.object.Custom;
  import java.util.*;
  import sailpoint.object.QueryInfo;
  import sailpoint.object.ProvisioningPlan;  
  import sailpoint.api.*;
  import sailpoint.tools.*;
  import java.lang.*;
  import java.text.*;
  import java.util.Calendar;
  
  
  String customObjName = "IdentityValues";
  Map list = new HashMap();
  List lstMail = new ArrayList();

  SailPointContext ctx = SailPointFactory.getCurrentContext();

  if ( ctx == null )
  {
   throw new GeneralException("Unable to get sailpoint context.");
  }

  Custom customObj=ctx.getObjectByName(Custom.class,customObjName);
  Custom customObj1=ctx.getObjectByName(Custom.class,"IIQClases");

 if (null != customObj1)
  {
    Collection getValues1 =  customObj1.getAttributes().getMap().values();
  
    Object [] ob= getValues1.toArray();
    System.out.println((List)ob[0]);
   //List l2 = (List)ob[0];
   // System.out.println(l2);
   //tring strClassname= l2.get(1);
   // System.out.println(strClassname);
   // return strClassname;
 }
  if (null != customObj)
  {
    Collection getValues =  customObj.getAttributes().getMap().values();
    Object [] ob= getValues.toArray();   

    int q= ob.length-1;
    int k = 0;
    while (k &lt;= q)
    {
      List l1 = (List)ob[k];
      String strEmpName= l1.get(1);
      
      List listofIdentities =  context.getObjects(Identity.class);
      for(Identity id : listofIdentities)
      {
        String strEmpidebtyName = id.getName();
        if(strEmpidebtyName.equalsIgnoreCase(strEmpName))
  			{
         System.out.println("Employee  Name::"+strEmpName+" Mail ID is::"+id.getEmail());
          String strEmail = id.getEmail();
          //Mail Sending code.
          String tplName = "SampleEmailTemplate";
          EmailTemplate template = context.getObjectByName(EmailTemplate.class, tplName);
          if (null == template) {
             log.error("ERROR: could not find email template [ " + tplName + "]");
          }
          Map args = new HashMap();
                   
         Calendar calendar = Calendar.getInstance();
         String[] days = new String[] { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
         String strWeekDay = days[calendar.get(Calendar.DAY_OF_WEEK) - 1];
          args.put("weekday",strWeekDay );
          args.put("empName", strEmpName);
          try
          {
              EmailOptions ops = new EmailOptions(strEmail, args);
              context.sendEmailNotification(template, ops);
          }
          catch (Exception e)
          {
            		log.error("Error in Email send operation : " + e);
          }
     		}        
      }    
      k=k+1;
    }
    
  }  
 else
 {
  throw new GeneralException("Unable to retrieve Custom object \"" + customObjName + "\"");
 }  
  return customObjName;
  </Source>
  </Rule>
  <Rule created="1661499852298" id="c0a8700182cf12bc8182d91bc60a0503" language="beanshell" modified="1661773780502" name="CR_2U_2E_Provisining" type="BeforeProvisioning">
    <Description>Custom Rule 
    1.Create plan for two users 2 entitlements of differnt application.
    2.Excute plan.
  
  </Description>
    <Source>
  import sailpoint.object.*;
  import sailpoint.tools.*;
  import sailpoint.object.ProvisioningPlan;
  import sailpoint.object.ProvisioningPlan.AccountRequest;
  import sailpoint.object.ProvisioningPlan.AttributeRequest; 
  import sailpoint.object.ProvisioningPlan.Operation;
  import java.util.*;
  import sailpoint.tools.*;
  import sailpoint.object.Filter;
  import sailpoint.object.QueryOptions;
  import sailpoint.connector.ConnectorFactory;
  import sailpoint.object.ManagedAttribute;
  import sailpoint.api.SailPointContext;
  import sailpoint.object.Application;
  import sailpoint.object.EntitlementGroup;
  import sailpoint.api.IdentityService;
  import sailpoint.api.*;
  
  String user1="Dorothy Robinson";
  String user2="Christopher Clark";
  String entiltlement1 = "ESHIAM\\AccountsPayable";//AD Entitlement 
  String entiltlement2 = "OpenLdapContractors";//OPEN LDAP Entitlement
  String adApplName = "";
  String openLDAPApplName = "";
  String accreqNativeIdAD = "";
  String accreqNativeIdOPENLDAP = "";
  String atrqADValue = "";
  String atrqOPENLDAPValue = "";
  
   //TO get application name of entitlement of memberof(AD)
  Filter filter = Filter.and(Filter.eq("attribute","memberof"),Filter.eq("displayName",entiltlement1));
  QueryOptions qr =  new QueryOptions();
  qr.addFilter(filter);
                             
  List listEnt = context.getObjects(ManagedAttribute.class,qr);
  
  for(ManagedAttribute mngatad: listEnt)
  {
    adApplName = mngatad.getApplication().getName();//Assuming only one application exist for each entitlement in Sailpoint    
    atrqADValue = mngatad.getValue();
    //return atrqADValue;
  }
   

  //TO get application name of entitlement of groups(OPENLDAP)
  Filter filter = Filter.and(Filter.eq("attribute","groups"),Filter.eq("displayName",entiltlement2));
  QueryOptions qr =  new QueryOptions();
  qr.addFilter(filter);
                             
  List listEnt = context.getObjects(ManagedAttribute.class,qr);
  
  for(ManagedAttribute mngatopnldap: listEnt)
  {
    openLDAPApplName = mngatopnldap.getApplication().getName();//Assuming only one application exist for each entitlement in Sailpoint
    atrqOPENLDAPValue = mngatopnldap.getValue();
  }
  
  Identity idUser1 = context.getObjectByName(Identity.class, user1);
  if (null == idUser1)
  {
   log.error("Could not find Identity object named:" + user1);
   return;
	}
  else
  {   
    Application app = context.getObjectByName(Application.class, adApplName);
    IdentityService ids = new IdentityService(context);
    
    List lnk = ids.getLinks(idUser1, app);
    for(Link llll: lnk)
    {
    	accreqNativeIdAD = llll.getNativeIdentity(); 
    }
  }
  
   
  Identity idUser2 = context.getObjectByName(Identity.class, user2);
  if (null == idUser2)
  {
   log.error("Could not find Identity object named:" + user2);
   return;
	}
  else
  {
    Application app = context.getObjectByName(Application.class, openLDAPApplName);
    IdentityService ids = new IdentityService(context);
    
    List lnk = ids.getLinks(idUser2, app);
    for(Link llll: lnk)
    {
    	accreqNativeIdOPENLDAP = llll.getNativeIdentity(); 
    }
    
  }
  
 /*PLAN 1
  1. Dorothy Robinson
  2. ESHIAM\\AccountsPayable";//AD Entitlement 
 */
     //Provisioning plan settings 
  AccountRequest AccReq = new AccountRequest();
  AttributeRequest atrb = new AttributeRequest();
  Provisioner provisioner = new Provisioner(context);
   ProvisioningPlan provPlanUser = new ProvisioningPlan();
  
  //Setting nativeidentity to plan (AD)
  provPlanUser.setNativeIdentity(user1);
  provPlanUser.setTargetIntegration(adApplName); 
  provPlanUser.setIdentity(idUser1);
  
  AccReq.setApplication(adApplName);
  AccReq.setNativeIdentity(accreqNativeIdAD);  
  AccReq.setOp(ProvisioningPlan.ObjectOperation.Modify);
  
  atrb.setValue(atrqADValue);//atrqADValue
  atrb.setName("memberOf");
  atrb.setDisplayValue(entiltlement1);
  AccReq.add(atrb);
  provPlanUser.add(AccReq);
  provisioner.execute(provPlanUser);
  context.commitTransaction();  

  
   /*PLAN 2
  1. Christopher Clark
  2. OpenLdapContractors";//OPEN LDAP Entitlement
  */
  
  AccReq=null;
  atrb=null;
  provisioner=null;
  provPlanUser=null;
  
  AccountRequest AccReq = new AccountRequest();
  AttributeRequest atrb = new AttributeRequest();
  Provisioner provisioner = new Provisioner(context);
  ProvisioningPlan provPlanUser = new ProvisioningPlan();
  
  //Setting nativeidentity to plan (OPENLDAP)
  provPlanUser.setNativeIdentity(user2);
  provPlanUser.setTargetIntegration(openLDAPApplName); 
  provPlanUser.setIdentity(idUser2);
  
  AccReq.setApplication(openLDAPApplName);
  AccReq.setNativeIdentity(accreqNativeIdOPENLDAP);  
  AccReq.setOp(ProvisioningPlan.ObjectOperation.Modify);
  
  atrb.setValue(atrqOPENLDAPValue);
  atrb.setName("groups");
  atrb.setDisplayValue(entiltlement2);
  AccReq.add(atrb);
  provPlanUser.add(AccReq);
  provisioner.execute(provPlanUser);
  context.commitTransaction(); 
  
  
    /*PLAN 3
  1. Dorothy Robinson
  2. OpenLdapContractors";//OPEN LDAP Entitlement
 */
     //Provisioning plan settings 
  AccountRequest AccReq = new AccountRequest();
  AttributeRequest atrb = new AttributeRequest();
  Provisioner provisioner = new Provisioner(context);
   ProvisioningPlan provPlanUser = new ProvisioningPlan();
  
  //Setting nativeidentity to plan 
  provPlanUser.setNativeIdentity(user1);
  provPlanUser.setTargetIntegration(openLDAPApplName); 
  provPlanUser.setIdentity(idUser1);
  
  AccReq.setApplication(openLDAPApplName);
  AccReq.setNativeIdentity(accreqNativeIdOPENLDAP);  
  AccReq.setOp(ProvisioningPlan.ObjectOperation.Modify);
  
  atrb.setValue(atrqOPENLDAPValue);//atrqADValue
  atrb.setName("groups");
  atrb.setDisplayValue(entiltlement2);
  AccReq.add(atrb);
  provPlanUser.add(AccReq);
  provisioner.execute(provPlanUser);
  context.commitTransaction();  
  
   /*PLAN 4
  1. Christopher Clark
  2.ESHIAM\\AccountsPayable";//AD Entitlement 
  */
  
  AccReq=null;
  atrb=null;
  provisioner=null;
  provPlanUser=null;
  
  AccountRequest AccReq = new AccountRequest();
  AttributeRequest atrb = new AttributeRequest();
  Provisioner provisioner = new Provisioner(context);
  ProvisioningPlan provPlanUser = new ProvisioningPlan();
  
  //Setting nativeidentity to plan (OPENLDAP)
  provPlanUser.setNativeIdentity(user2);
  provPlanUser.setTargetIntegration(adApplName); 
  provPlanUser.setIdentity(idUser2);
  
  AccReq.setApplication(adApplName);
  AccReq.setNativeIdentity(accreqNativeIdAD);  
  AccReq.setOp(ProvisioningPlan.ObjectOperation.Modify);
  
  atrb.setValue(atrqADValue);
  atrb.setName("memberOf");
  atrb.setDisplayValue(entiltlement1);
  AccReq.add(atrb);
  provPlanUser.add(AccReq);
  provisioner.execute(provPlanUser);
  context.commitTransaction(); 
  
  
  
  </Source>
  </Rule>
  <Rule created="1661749086356" id="c0a8700182df116e8182e7f6c89300fd" language="beanshell" name="BPR_OPenLDAP" type="BeforeProvisioning">
    <Description>An IdentityIQ server-side rule that is executed before the connector's provisioning method is called. This gives the customer the ability to customize or react to anything in the ProvisioningPlan BEFORE it is sent to the underlying connectors used in provisioning. 

This rule will be called for any application found in a plan that also has a configured 'beforeProvisioningRule' configured.  

The plan can be updated directly in the rule by reference and does not need to return the plan.</Description>
    <Signature>
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="plan">
          <Description>
          The ProvisioningPlan object on its way to the Connector.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The application object that references this before/after script.
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>import sailpoint.object.*;
import sailpoint.tools.*;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest; 
import sailpoint.object.ProvisioningPlan.Operation;
import java.util.*;
import sailpoint.tools.*;
import sailpoint.object.Filter;
import sailpoint.object.QueryOptions;
import sailpoint.connector.ConnectorFactory;

System.out.println("OPENLDAP Before provision Plan Object::\n"+ plan.toXml());

/*String strApplicationName = application.getName();
System.out.println(strApplicationName);
  
String strGroupAssign = "ESHIAM\\BenefitCommittee";
String strGroupDefaultAssign = "ESHIAM\\All_Userse";
String strGroupPreAssign = "ESHIAM\\Benefits";
  
if(strApplicationName.equalsIgnoreCase("AD_Application"))
{
  List addAttributeRequests = new List();
  //ProvisioningPlan plan = new ProvisioningPlan();
		
  List lstAccountRequest = new ArrayList();

		for(AccountRequest atr:lstAccountRequest)
		{
          List lstAttirbuterequest = atr.getAttributeRequests();
          //System.out.println(lstAttirbuterequest);
          for(AttributeRequest atbr:lstAttirbuterequest)
          {
            String str2= atbr.getDisplayValue();
            if ( strGroupPreAssign.compareTo(str2) == 0 )
            {
              AttributeRequest req = new AttributeRequest(atbr);
              req.setNamestrGroupAssign();
              lstAccountRequest.add(req);
            }		
        }
		}
}
*/
/*
Application applicationAD = context.getObjectByName(Application.class, "AD_Application");
Connector appConnector = sailpoint.connector.ConnectorFactory.getConnector(applicationAD, null).getInternalConnector();

//System.out.println(appConnector);

Filter filter = Filter.eq("sAMAccountName", "Sadeep Cheela" );
System.out.println("After Filter");

CloseableIterator itr = appConnector.iterateObjects("account", filter, null);
//Iterator itr = appConnector.iterateObjects(filter);

System.out.println("After CloseableIterator ");

//System.out.println("After CloseableIterator "+itr.next().toMap());
while ( (null != itr) &amp;&amp; (itr.hasNext()) )
{
 System.out.println("Inside while ");
 HashMap accountdetails = itr.next().toMap();
 System.out.println(accountdetails);
}*/</Source>
  </Rule>
  <Rule created="1662532079184" id="c0a8700183121483818316a24e500214" language="beanshell" modified="1664269850852" name="GroupOwnerRuleTogetidofManager1A" type="GroupOwner">
    <Description>A rule used to assign owners to groups generated from a group factory.</Description>
    <Signature returnType="Object">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="factory">
          <Description>
          The GroupFactory that generated the populations.
        </Description>
        </Argument>
        <Argument name="group">
          <Description>
          One GroupDefinition from the factory.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="owner">
          <Description>
          The group owner. The name or id of an Identity or the Identity object itself.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import sailpoint.object.*;
  import sailpoint.tools.*;
  import sailpoint.object.ProvisioningPlan;
  import sailpoint.object.ProvisioningPlan.AccountRequest;
  import sailpoint.object.ProvisioningPlan.AttributeRequest; 
  import sailpoint.object.ProvisioningPlan.Operation;
  import java.util.*;
  import sailpoint.tools.*;
  import sailpoint.object.Filter;
  import sailpoint.object.QueryOptions;
  import sailpoint.connector.ConnectorFactory;
  import sailpoint.object.ManagedAttribute;
  import sailpoint.api.SailPointContext;
  import sailpoint.object.Application;
  import sailpoint.object.EntitlementGroup;
  import sailpoint.api.IdentityService;
  import sailpoint.api.*;

/*TO get identies whose manager is 1A
  Filter filter = Filter.eq("manager","1A");
  QueryOptions qr =  new QueryOptions();
  qr.addFilter(filter);
                             
  List listID = context.getObjects(Idenntity.class,qr);
  
return context.getObjects(Idenntity.class,"1A");
*/
  return null;
  </Source>
  </Rule>
  <Rule created="1663648600756" id="c0a8700183501ea38183592f12b30917" language="beanshell" modified="1663934201598" name="JDBCGlobalProvisionRule" type="JDBCProvision">
    <Description>This rule is used by the JDBC connector to do provisioning of the data.</Description>
    <Signature returnType="ProvisioningResult">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
                The application whose data file is being processed.
                </Description>
        </Argument>
        <Argument name="schema">
          <Description>
                The Schema currently in use.
                </Description>
        </Argument>
        <Argument name="connection">
          <Description>
                A connection object to connect to database.
                </Description>
        </Argument>
        <Argument name="plan">
          <Description>
                The ProvisioningPlan created against the JDBC application.
                </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="result">
          <Description>
                A Provisioning Result object is desirable to return the status.IT can be a new object or part of  Provisioning Plan
                </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.util.List;
import sailpoint.api.SailPointContext;
import sailpoint.connector.JDBCConnector;
import sailpoint.object.Application;
import sailpoint.object.ProvisioningPlan;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.ProvisioningPlan.PermissionRequest;
import sailpoint.object.ProvisioningResult;
import sailpoint.object.Schema;
import sailpoint.tools.xml.XMLObjectFactory;
import org.apache.commons.logging.LogFacttory;
import org.apache.commons.logging.Log;

public String getAttributeRequestValue(AccountRequest acctReq, String attribute) {
if ( acctReq != null ) 
{
     AttributeRequest attrReq = acctReq.getAttributeRequest(attribute);
      if ( attrReq != null ) 
{
 return attrReq.getValue();
 }
 }
 return null;
}
ProvisioningResult result = new ProvisioningResult();
if ( plan != null ) {
System.out.println( "plan [" + plan.toXml() + "]" );
List accounts = plan.getAccountRequests();
if ( ( accounts != null ) &amp;&amp; ( accounts.size() > 0 ) ) {
 for ( AccountRequest account : accounts ) {
try {
if ( AccountRequest.Operation.Create.equals( account.getOperation() ) ) {
 List attributerequests = account.getAttributeRequests();
            
            String strgrpname = context.getObjectById(ManagedAttribute.class,account.getArgument("id")).getValue();
            for (AttributeRequest attrequest : attributerequests) 
            {
              PreparedStatement statement = connection.prepareStatement("insert into  test.jdbcusers (Name,FirstName,LastName,EmployeeID,EmailAddress,NetworkID,GroupId,Status) values (?,?,?,?,?,?,?,?)" );
              statement.setString ( 1, getAttributeRequestValue(account,"FirstName") );
              statement.setString ( 2, getAttributeRequestValue(account,"FirstName") );
              statement.setString ( 3, getAttributeRequestValue(account,"LastName") );
              statement.setString ( 4, (String) account.getNativeIdentity() );
              statement.setString ( 5, getAttributeRequestValue(account,"EmailAddress") );
              statement.setString ( 6, getAttributeRequestValue(account,"NetworkID") );
              statement.setString ( 7,strgrpname);
              statement.setString ( 8, "True" );
              System.out.println("Statement::::"+statement );
              statement.executeUpdate();
              result.setStatus( ProvisioningResult.STATUS_COMMITTED );
              return result;
            }
} else if ( AccountRequest.Operation.Modify.equals( account.getOperation() ) 
) {
// Modify account request -- change role
System.out.println( "Operation [" + account.getOperation() + "] detected." );
PreparedStatement statement = connection.prepareStatement( "update users 
set role = ? where login = ?" );
statement.setString ( 2, (String) account.getNativeIdentity() );
if ( account != null ) {
AttributeRequest attrReq = account.getAttributeRequest("role");
if ( attrReq != null &amp;&amp; ProvisioningPlan.Operation.Remove.equals(attrReq.getOperation()) ) {
statement.setNull ( 1, Types.NULL );
System.out.println( "Preparing to execute:"+statement.toString() );
 statement.executeUpdate();
 } else {
statement.setString(1,attrReq.getValue());
System.out.println( "Preparing to execute:"+statement.toString() );
statement.executeUpdate();
}
}
result.setStatus( ProvisioningResult.STATUS_COMMITTED );
} else if ( AccountRequest.Operation.Delete.equals( account.getOperation() ) 
) {
System.out.println( "Operation [" + account.getOperation() + "] detected." );
PreparedStatement statement = connection.prepareStatement( (String) 
application.getAttributeValue( "account.deleteSQL" ) );
statement.setString ( 1, (String) account.getNativeIdentity() );
statement.executeUpdate();
result.setStatus( ProvisioningResult.STATUS_COMMITTED );
} else if ( AccountRequest.Operation.Disable.equals( account.getOperation() 
) ) {
// Not supported.
System.out.println( "Operation [" + account.getOperation() + "] is not 
supported!" );
} else if ( AccountRequest.Operation.Enable.equals( account.getOperation() ) 
) {
// Not supported.
System.out.println( "Operation [" + account.getOperation() + "] is not 
supported!" );
} else if ( AccountRequest.Operation.Lock.equals( account.getOperation() ) ) 
{
// Not supported.
System.out.println( "Operation [" + account.getOperation() + "] is not 
supported!" );
} else if ( AccountRequest.Operation.Unlock.equals( account.getOperation() ) 
) {
// Not supported.
System.out.println( "Operation [" + account.getOperation() + "] is not 
supported!" );
} else {
// Unknown operation!
System.out.println( "Unknown operation [" + account.getOperation() + "]!" );
}
}
catch( SQLException e ) { 

result.setStatus( ProvisioningResult.STATUS_FAILED );
result.addError( e );
 }
 }
 }
}
System.out.println( "result [" + result.toXml(false)+ "]");
return result;</Source>
  </Rule>
  <Rule created="1663669354041" id="c0a8700183501ea381835a6bbe390d36" language="beanshell" modified="1664291243768" name="JDBCModifyProvision" type="JDBCOperationProvisioning">
    <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
    <Signature returnType="ProvisioningResult">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>The application whose data file is being processed.</Description>
        </Argument>
        <Argument name="schema">
          <Description>The Schema currently in use.</Description>
        </Argument>
        <Argument name="connection">
          <Description>A connection object to connect to database.</Description>
        </Argument>
        <Argument name="plan">
          <Description>The ProvisioningPlan created against the JDBC application.</Description>
        </Argument>
        <Argument name="request">
          <Description>The ProvisioningRequest created against the JDBC application.</Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="result">
          <Description>A Provisioning Result object is desirable to return the status.IT can be a new object or part of  Provisioning Plan</Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.util.List;
import sailpoint.api.SailPointContext;
import sailpoint.connector.JDBCConnector;
import sailpoint.object.Application;
import sailpoint.object.ProvisioningPlan.*;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.ProvisioningPlan.PermissionRequest;
import sailpoint.object.ProvisioningResult;
import sailpoint.object.Schema;
import sailpoint.tools.xml.XMLObjectFactory;
import org.apache.commons.logging.LogFacttory;
import org.apache.commons.logging.Log;		
  System.out.println("Modify:::   "+plan.toXml());
  
  public String getAttributeRequestValue(AccountRequest acctReq, String attribute) 
  {
    if ( acctReq != null )
    {
      AttributeRequest attrReq = acctReq.getAttributeRequest(attribute);
      if ( attrReq != null )
      {
        return attrReq.getValue();
      }
    }
    return null;
  }
  

// Modify account request -- GroupId
		ProvisioningResult result = new ProvisioningResult();
    result.setStatus( ProvisioningResult.STATUS_FAILED);
		List accounts = plan.getAccountRequests();
		if ( ( accounts != null ) &amp;&amp; ( accounts.size() > 0 ) ) 
		{
       System.out.println("1111" );
		 for ( AccountRequest account : accounts )
		 {
        System.out.println("22222" );
				System.out.println( "Operation [" + account.getOperation() + "] detected." );
				
				if ( account != null )
		{
           System.out.println("33333" );
					 List attributerequests = account.getAttributeRequests();
					
		  for (AttributeRequest attrequest : attributerequests) 
		    {			 
			  System.out.println("4444444" );
        System.out.println("ACC:: "+AccountRequest.Operation.Modify);
        System.out.println("ACC PLAN:: "+account.getOperation());
        System.out.println("ATRB:: "+attrequest.getOperation());
        String straccop=attrequest.getOperation().toString();
        // System.out.println("straccop:: "+straccop);
        
			  if(AccountRequest.Operation.Modify.equals( account.getOperation()) &amp;&amp; straccop.equals("Add"))
			{
               System.out.println("555555555" );
				  			if(attrequest.getName().equals("GroupId"))                
	               {   
                   System.out.println("666666666666666" );
	                System.out.println("groupID::"+getAttributeRequestValue(account,"GroupId"));
	                PreparedStatement statement = connection.prepareStatement("insert into  test.jdbcusers (Name,FirstName,LastName,EmployeeID,EmailAddress,NetworkID,GroupId,Status) values (?,?,?,?,?,?,?,?)" );
	                statement.setString ( 1, getAttributeRequestValue(account,"FirstName") );
	                statement.setString ( 2, getAttributeRequestValue(account,"FirstName") );
	                statement.setString ( 3, getAttributeRequestValue(account,"LastName") );
	                statement.setString ( 4, (String) account.getNativeIdentity() );
	                statement.setString ( 5, getAttributeRequestValue(account,"EmailAddress") );
	                statement.setString ( 6, getAttributeRequestValue(account,"NetworkID") );
	                statement.setString ( 7, attrequest.getValue());
	                statement.setString ( 8, "True" );
	                System.out.println("Statement::::"+statement );
	                statement.executeUpdate();
	                result.setStatus( ProvisioningResult.STATUS_COMMITTED );
	               }   
			  }
			  else if(straccop.equals("Remove"))
			  {
            if(attrequest.getName().equals("GroupId"))                
            {                   
              System.out.println("groupID::"+getAttributeRequestValue(account,"GroupId"));
              PreparedStatement statement = connection.prepareStatement("delete from test.jdbcusers where EmployeeID=? and GroupID=?");
              System.out.println(statement);	              
              statement.setString ( 1, (String) account.getNativeIdentity() );	
              statement.setString ( 2, attrequest.getValue());
              System.out.println("Statement::::"+statement );
              statement.executeUpdate();
              result.setStatus( ProvisioningResult.STATUS_COMMITTED );
            }             
			  }
         
		    }         
        
		}
		}
        return result;
		}</Source>
  </Rule>
  <Rule created="1663670108256" id="c0a8700183501ea381835a7740600d7f" language="beanshell" modified="1665678817957" name="JDBCCreateProvision" type="JDBCOperationProvisioning">
    <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
    <Signature returnType="ProvisioningResult">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>The application whose data file is being processed.</Description>
        </Argument>
        <Argument name="schema">
          <Description>The Schema currently in use.</Description>
        </Argument>
        <Argument name="connection">
          <Description>A connection object to connect to database.</Description>
        </Argument>
        <Argument name="plan">
          <Description>The ProvisioningPlan created against the JDBC application.</Description>
        </Argument>
        <Argument name="request">
          <Description>The ProvisioningRequest created against the JDBC application.</Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="result">
          <Description>A Provisioning Result object is desirable to return the status.IT can be a new object or part of  Provisioning Plan</Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import java.sql.Connection;
  import java.sql.DriverManager;
  import java.sql.SQLException;
  import java.sql.ResultSet;
  import java.sql.Statement;
  import java.sql.CallableStatement;
  import java.sql.Types;
  import java.sql.*;
  import java.io.*;
  import java.util.List;
  import sailpoint.api.SailPointContext;
  import sailpoint.connector.JDBCConnector;
  import sailpoint.object.Application;
  import sailpoint.object.ProvisioningPlan.*;
  import sailpoint.object.ProvisioningPlan.AccountRequest;
  import sailpoint.object.ProvisioningPlan.AttributeRequest;
  import sailpoint.object.ProvisioningPlan.PermissionRequest;
  import sailpoint.object.ProvisioningResult;
  import sailpoint.object.Schema;
  import sailpoint.tools.xml.XMLObjectFactory;
  import org.apache.commons.logging.LogFacttory;
  import org.apache.commons.logging.Log;
  import sailpoint.object.ManagedAttribute;
   import sailpoint.object.*;
  
  
   System.out.println("JDBC Create provision:::   "+plan.toXml());

  ProvisioningResult result = new ProvisioningResult();
  result.setStatus( ProvisioningResult.STATUS_FAILED);
  public String getAttributeRequestValue(AccountRequest acctReq, String attribute) 
  {
    if ( acctReq != null )
    {
      AttributeRequest attrReq = acctReq.getAttributeRequest(attribute);
      if ( attrReq != null )
      {
        return attrReq.getValue();
      }
    }
    return null;
  }
  
  System.out.println( "plan [" + plan.toXml() + "]" );


  if ( plan != null ) {
    List accounts = plan.getAccountRequests();
    if ( ( accounts != null ) &amp;&amp; ( accounts.size() > 0 ) ) {
      for ( AccountRequest account : accounts ) {
        try {
          if ( AccountRequest.Operation.Create.equals( account.getOperation() ) ) {        
            
            /* //Checking for account exist in Database.
            PreparedStatement statement1 = connection.prepareStatement("select count(*)  from test.jdbcusers where  EmployeeID=?");
            statement1.setString ( 1, (String) account.getNativeIdentity());
            ResultSet rs=statement1.executeQuery();
            while (rs.next())
            {
              if( (int)rs.getInt(1) > 0)
              {
                System.out.println("Employee already exist can not create this employee:: "+(String) account.getNativeIdentity());
                return null;
              }
            }
            */

            List attributerequests = account.getAttributeRequests();
            
            //String strgrpname = context.getObjectById(ManagedAttribute.class,account.getArgument("id")).getValue();
            for (AttributeRequest attrequest : attributerequests) 
            {
               System.out.println("SSSSSSSSSSSSSSSSS::"+attrequest.getName());
              String user = plan.getNativeIdentity();	
                  System.out.println("2");
		          Identity id =context.getObjectByName(Identity.class, user);
                 System.out.println("2Test"+id);
               if(attrequest.getName().equals("GroupId"))                
               {    
                System.out.println("groupID::"+getAttributeRequestValue(account,"GroupId"));
                PreparedStatement statement = connection.prepareStatement("insert into  test.jdbcusers (Name,FirstName,LastName,EmployeeID,EmailAddress,NetworkID,GroupId,Status) values (?,?,?,?,?,?,?,?)" );
                statement.setString ( 1, getAttributeRequestValue(account,"Name") );
                statement.setString ( 2, getAttributeRequestValue(account,"FirstName") );
                statement.setString ( 3, getAttributeRequestValue(account,"LastName") );
                statement.setString ( 4, id.getAttribute("EmployeeID") );
                statement.setString ( 5, getAttributeRequestValue(account,"EmailAddress") );
                statement.setString ( 6, getAttributeRequestValue(account,"NetworkID") );
                statement.setString ( 7, attrequest.getValue());
                statement.setString ( 8, "True" );
                System.out.println("Statement::::"+statement );
                statement.executeUpdate();
                result.setStatus( ProvisioningResult.STATUS_COMMITTED );
               }              
            }
            return result;
          }
        }
          catch( SQLException e )
          {   
            log.error( e );
            result.setStatus( ProvisioningResult.STATUS_FAILED );
            result.addError( e );
          }

        }
      }
    }</Source>
  </Rule>
  <Rule created="1663764402910" id="c0a87001835e16268183601612de031c" language="beanshell" name="JDBCDeleteUser" type="JDBCOperationProvisioning">
    <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
    <Signature returnType="ProvisioningResult"/>
    <Source>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.util.List;
import sailpoint.api.SailPointContext;
import sailpoint.connector.JDBCConnector;
import sailpoint.object.Application;
import sailpoint.object.ProvisioningPlan.*;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.ProvisioningPlan.PermissionRequest;
import sailpoint.object.ProvisioningResult;
import sailpoint.object.Schema;
import sailpoint.tools.xml.XMLObjectFactory;
import org.apache.commons.logging.LogFacttory;
import org.apache.commons.logging.Log;		

// Modify account request -- GroupId
ProvisioningResult result = new ProvisioningResult();
List accounts = plan.getAccountRequests();
if ( ( accounts != null ) &amp;&amp; ( accounts.size() > 0 ) ) 
{
 for ( AccountRequest account : accounts )
 {
		System.out.println( "Operation [" + account.getOperation() + "] detected." );
		PreparedStatement statement = connection.prepareStatement( "DELETE FROM  test.jdbcusers WHERE EmployeeID=?" );
               System.out.println(statement);
		if ( account != null )
{
			        AttributeRequest attrReq = account.getAttributeRequest("GroupId");
				statement.setString(1,, (String) account.getNativeIdentity());
				System.out.println( "Preparing to execute:"+statement.toString() );
				statement.executeUpdate();
	
		result.setStatus( ProvisioningResult.STATUS_COMMITTED );
}
}
return result;
}</Source>
  </Rule>
  <Rule created="1663826405336" id="c0a87001835e1626818363c827d80447" language="beanshell" name="JDBCUserEnable" type="JDBCOperationProvisioning">
    <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
    <Signature returnType="ProvisioningResult"/>
    <Source>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.util.List;
import sailpoint.api.SailPointContext;
import sailpoint.connector.JDBCConnector;
import sailpoint.object.Application;
import sailpoint.object.ProvisioningPlan.*;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.ProvisioningPlan.PermissionRequest;
import sailpoint.object.ProvisioningResult;
import sailpoint.object.Schema;
import sailpoint.tools.xml.XMLObjectFactory;
import org.apache.commons.logging.LogFacttory;
import org.apache.commons.logging.Log;		

// Modify account request -- GroupId
ProvisioningResult result = new ProvisioningResult();
List accounts = plan.getAccountRequests();
if ( ( accounts != null ) &amp;&amp; ( accounts.size() > 0 ) ) 
{
 for ( AccountRequest account : accounts )
 {
		System.out.println( "Operation [" + account.getOperation() + "] detected." );
		PreparedStatement statement = connection.prepareStatement( "update test.jdbcusers set Status= ? where EmployeeID= ?" );
               System.out.println(statement);
		statement.setString ( 2, (String) account.getNativeIdentity() );
		if ( account != null )
{
			        AttributeRequest attrReq = account.getAttributeRequest("GroupId");
				statement.setString(1,"true");
				System.out.println( "Preparing to execute:"+statement.toString() );
				statement.executeUpdate();
	
		result.setStatus( ProvisioningResult.STATUS_COMMITTED );
}
}
return result;
}</Source>
  </Rule>
  <Rule created="1663826439203" id="c0a87001835e1626818363c8ac230448" language="beanshell" name="JDBCUserDisable" type="JDBCOperationProvisioning">
    <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
    <Signature returnType="ProvisioningResult"/>
    <Source>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.util.List;
import sailpoint.api.SailPointContext;
import sailpoint.connector.JDBCConnector;
import sailpoint.object.Application;
import sailpoint.object.ProvisioningPlan.*;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.ProvisioningPlan.PermissionRequest;
import sailpoint.object.ProvisioningResult;
import sailpoint.object.Schema;
import sailpoint.tools.xml.XMLObjectFactory;
import org.apache.commons.logging.LogFacttory;
import org.apache.commons.logging.Log;		

// Modify account request -- GroupId
ProvisioningResult result = new ProvisioningResult();
List accounts = plan.getAccountRequests();
if ( ( accounts != null ) &amp;&amp; ( accounts.size() > 0 ) ) 
{
 for ( AccountRequest account : accounts )
 {
		System.out.println( "Operation [" + account.getOperation() + "] detected." );
		PreparedStatement statement = connection.prepareStatement( "update test.jdbcusers set Status= ? where EmployeeID= ?" );
               System.out.println(statement);
		statement.setString ( 2, (String) account.getNativeIdentity() );
		if ( account != null )
{
			        AttributeRequest attrReq = account.getAttributeRequest("GroupId");
				statement.setString(1,"false");
				System.out.println( "Preparing to execute:"+statement.toString() );
				statement.executeUpdate();
	
		result.setStatus( ProvisioningResult.STATUS_COMMITTED );
}
}
return result;
}</Source>
  </Rule>
  <Rule created="1663836775769" id="c0a87001835e1626818364666559054f" language="beanshell" modified="1663836848343" name="JDBCUnlockUser" type="JDBCOperationProvisioning">
    <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
    <Signature returnType="ProvisioningResult"/>
    <Source>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.util.List;
import sailpoint.api.SailPointContext;
import sailpoint.connector.JDBCConnector;
import sailpoint.object.Application;
import sailpoint.object.ProvisioningPlan.*;
import sailpoint.object.ProvisioningPlan.AccountRequest;
import sailpoint.object.ProvisioningPlan.AttributeRequest;
import sailpoint.object.ProvisioningPlan.PermissionRequest;
import sailpoint.object.ProvisioningResult;
import sailpoint.object.Schema;
import sailpoint.tools.xml.XMLObjectFactory;
import org.apache.commons.logging.LogFacttory;
import org.apache.commons.logging.Log;	

ProvisioningResult result = new ProvisioningResult();
		if ( plan != null ) {
			System.out.println( "plan [" + plan.toXml() + "]" );
		List accounts = plan.getAccountRequests();
		if ( ( accounts != null ) &amp;&amp; ( accounts.size() > 0 ) ) {
		 for ( AccountRequest account : accounts ) {
		try {
		if ( AccountRequest.Operation.Create.equals( account.getOperation() ) )
 {

			System.out.println( "Operation [" + account.getOperation() + "] detected." );
			//Checking for account exest in Database.
			if(account.getIdentity().getLock() != null) 
                    {
				
				account.getIdentity().setLock(account.getIdentity().getLock());
			}
}
catch( SQLException e ) { 
			System.out.println( e );
		result.setStatus( ProvisioningResult.STATUS_FAILED );
		result.addError( e );
		 }
}
}</Source>
  </Rule>
  <Rule created="1664186239717" id="c0a87001837911dc8183793acae5002d" language="beanshell" name="printPlan" type="BeforeProvisioning">
    <Description>An IdentityIQ server-side rule that is executed before the connector's provisioning method is called. This gives the customer the ability to customize or react to anything in the ProvisioningPlan BEFORE it is sent to the underlying connectors used in provisioning. 

This rule will be called for any application found in a plan that also has a configured 'beforeProvisioningRule' configured.  

The plan can be updated directly in the rule by reference and does not need to return the plan.</Description>
    <Signature>
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="plan">
          <Description>
          The ProvisioningPlan object on its way to the Connector.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The application object that references this before/after script.
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>System.out.println("beforePlan==="+plan.toXml());</Source>
  </Rule>
  <Rule created="1664276783185" id="c0a87001837e186a81837ea06051020e" language="beanshell" name="Modify_print_plan" type="JDBCOperationProvisioning">
    <Description>This rule is used by the JDBC connector to do provisioning of the data .</Description>
    <Signature returnType="ProvisioningResult"/>
    <Source>System.out.println("=============The plan in modify :"+plan.toXml());</Source>
  </Rule>
  <Rule created="1664347805702" id="c0a87001838210fc818382dc1806001a" language="beanshell" modified="1664436520501" name="Delimited_PreIterate_Rule_FileLimitCheck" type="PreIterate">
    <Description>This rule is called before the connector processes the data in a file.</Description>
    <Signature returnType="void"/>
    <Source>
import java.io.IOException;
import java.util.*;
import java.io.File;
import java.io.FileReader;
import java.util.List;
import java.util.stream.Stream;
package com.zetcode;
import org.apache.commons.io.FileUtils;    
 try
 {
		String stringFilepath = application.getAttributeValue("file");//Get file path from application   
    /*System.out.println(" application.getAttributeValue::: "+ application);
    System.out.println(" log::: "+ log);
    System.out.println(" context::: "+ context);
    System.out.println(" schema::: "+ schema);
    System.out.println(" stats::: "+ stats);
    */
     File f = new File(stringFilepath);
     long fileSize = FileUtils.sizeOf(f);   
     System.out.format("The size of the file: %d bytes", fileSize);
     if(fileSize > 1000)
     {
       //System.out.println("The size of the file exceeds: 1000 bytes");
       throw new ArithmeticException("The size of the file exceeds: 1000 bytese!!");  
       return null;
     }    
 } 
catch( Exception e )
{ 
	System.out.println("Exception :: " + e.getMessage ());     
}	
  
</Source>
  </Rule>
  <Rule created="1664350738490" id="c0a87001838210fc81838308d83a0067" language="beanshell" modified="1664443364098" name="CreateRulePasswordset" type="IdentityCreation">
    <Description>Identity creation rules are used to set attributes on new Identity objects when they are created.  New identities may be created during the aggregation of application accounts, or optionally created after pass-through authentication.

One common operation is to change the name property of the identity when the default application name is complex (such as a directory DN).

Another common operation is to assign a set of initial capabilities based on the attributes pulled from the application account.</Description>
    <Signature returnType="void"/>
    <Source>import java.io.IOException;
import java.util.*;
import java.io.File;
import java.io.FileReader;
import java.util.List;
import java.util.stream.Stream;
import sailpoint.api.SailPointFactory;
import sailpoint.api.SailPointContext;
import sailpoint.tools.GeneralException;
import sailpoint.object.Custom;

System.out.println("You are in creation rule");
String fn=account.getAttribute("GivenName");
String ln=account.getAttribute("Surname");
String Pswd= fn+"%$#@"+ln;
//Make sure Password account custom attribute is created before this.
account.setAttribute("Password",Pswd);
System.out.println("You are in creation rule exit");

/*
String custobjName = "Created_Correlated_Users";
		Custom custlst = context.getObjectByName( Custom.class, custobjName);
		if(custlst != null)
		{
			
			
		}
		else
		{   
			Custom cust=new Custom();
			cust.setName(custobjName);
			// Now add some attributes:

			cust.put( "someKey1", "someValue" );

			cust.put( "someKey2", Arrays.asList( new String[] {"listValue1", "listValue2", "listValue3"} ) );

			cust.put( "someKey3", true );

			context.saveObject( cust );

			context.commitTransaction();

			System.out.println( cust.toXml() );
		}
    */</Source>
  </Rule>
  <Rule created="1664356464298" id="c0a87001838210fc8183836036a900d8" language="beanshell" modified="1664444008867" name="del-bm_changedep" type="BuildMap">
    <Description>This rule is used by the delimited file connector to build a map representation of the delimited data.</Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The application whose data file is being processed.
        </Description>
        </Argument>
        <Argument name="schema">
          <Description>
          The Schema currently in use.
        </Description>
        </Argument>
        <Argument name="state">
          <Description>
          A Map containing state information.
        </Description>
        </Argument>
        <Argument name="record">
          <Description>
          A List of data tokens parsed from the current line of the data file.
        </Description>
        </Argument>
        <Argument name="cols">
          <Description>
          A List of the columns to use.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="map">
          <Description>
          A Map of the resource object assembled from the data.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import sailpoint.connector.DelimitedFileConnector;
import sailpoint.object.Permission;

System.out.println("You are in build map rule::  " + map);  
/*System.out.println("You are in build map rule  Log::  " + log);  
System.out.println("You are in build map rule  context::  " + context);  
System.out.println("You are in build map rule  application::  " + application);  
System.out.println("You are in build map rule  schema::  " + schema);  
System.out.println("You are in build map rule  state::  " + state);  
System.out.println("You are in build map rule  record::  " + rocord);  
System.out.println("You are in build map rule  cols::  " + cols);  
*/
Map map = DelimitedFileConnector.defaultBuildMap(cols, record);
//System.out.println("map: " + map);  

	String strDep = (String) map.get("Department");
  if(strDep.equals("Executive Management"))
  {
    //String name = (String) map.get("Name");
   //System.out.println("name: " + name);  
    map.put("Department","Security Management");
     System.out.println("map: " + map);  

  }
 //System.out.println("map: " + map);  
return map;</Source>
  </Rule>
  <Rule created="1664361580048" id="c0a87001838210fc818383ae46100161" language="beanshell" modified="1664445659593" name="fnlnCustomNickName" type="ResourceObjectCustomization">
    <Description>This rule is configured on the application and is called after the connector has build a ResourceObject from the native application data.

Initially designed for non-rule based connectors to add SPPrivileged flag to an object, but could be used to do any transformations.</Description>
    <Signature returnType="ResourceObject">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="object">
          <Description>
          The ResourceObject built by the connector.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          Application that references the connector.
        </Description>
        </Argument>
        <Argument name="connector">
          <Description>
          The connector object.
        </Description>
        </Argument>
        <Argument name="state">
          <Description>
          A Map containing state information.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="resourceObject">
          <Description>
          The updated resource object.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import java.io.* ;
import java.util.*;
import java.io.BufferedReader;  
import java.io.FileReader;  
import java.io.IOException; 
import sailpoint.object.Identity;
System.out.println("You are in Customization Rule");
//System.out.println("Object:: "+application.toXml());
String fn=object.get("GivenName");
System.out.println("First Name:: "+fn);
String ln=object.get("Surname");
System.out.println("Last Name:: "+ln);
  //Take  last name first 4 letters
   if(ln.length()>4)
  {
    ln=ln.substring(0,4);
    System.out.println("Trin 4 char of Last Name:: "+ln);
  }
String nickName = fn+" "+ln;
 
System.out.println("Nick Name :: "+nickName);
object.put("NickName",nickName);
return object;</Source>
  </Rule>
  <Rule created="1664434461649" id="c0a87001838210fc818388065bd003d4" language="beanshell" name="DelFIleSizeCheck" type="PreIterate">
    <Description>This rule is called before the connector processes the data in a file.</Description>
    <Signature returnType="void">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          Application being iterated.
        </Description>
        </Argument>
        <Argument name="schema">
          <Description>
          Schema representing the data being iterated.
        </Description>
        </Argument>
        <Argument name="stats">
          <Description>
          A map passed by the connector of the stats for the file about to be iterated.
          Contains keys:
            fileName : (String) filename of the file about to be processed
            absolutePath : (String) absolute filename
            length : (Long) length in bytes
            lastModified : (Long) last time the file was updated Java GMT
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>import java.io.IOException;
import java.util.*;
import java.io.File;
import java.io.FileReader;
import java.util.List;
import java.util.stream.Stream;
package com.zetcode;
import org.apache.commons.io.FileUtils;    
  try
  {
		String stringFilepath = application.getAttributeValue("file");//Get file path from application   
    /*System.out.println(" application.getAttributeValue::: "+ application);
    System.out.println(" log::: "+ log);
    System.out.println(" context::: "+ context);
    System.out.println(" schema::: "+ schema);
    System.out.println(" stats::: "+ stats);
    */
     File f = new File(stringFilepath);
     long fileSize = FileUtils.sizeOf(f);   
     System.out.format("The size of the file: %d bytes", fileSize);
     if(fileSize > 1000)
     {
       System.out.println("The size of the file exceeds: 1000 bytes");
       throw new ArithmeticException("The size of the file exceeds: 1000 bytese!!");  
     }    
  } 
  catch( Exception e )
  { 
		System.out.println("Exception :: " + e.getMessage ());     
  }	
   return null;</Source>
  </Rule>
  <Rule created="1664522655534" id="c0a8700183881e5c81838d48172e03de" language="beanshell" modified="1664530708010" name="Task7_Correlation_Rule" type="Correlation">
    <Description>Identity Correlation Rules are used to find identities to which new accounts can be attached.

A correlation rule must return a Map with one of the specified Return arguments.</Description>
    <Signature returnType="Map">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="environment" type="Map">
          <Description>
          Arguments passed to the aggregation task.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          Application being aggregated.
        </Description>
        </Argument>
        <Argument name="account">
          <Description>
          A sailpoint.object.ResourceObject returned from the
          collector.
        </Description>
        </Argument>
        <Argument name="link">
          <Description>
          Existing link to this account.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="identityName">
          <Description>
          The name of an Identity object.
        </Description>
        </Argument>
        <Argument name="identity">
          <Description>
          A fully resolved Identity object if the rule wants
          to do its own queries to locate the identity.
        </Description>
        </Argument>
        <Argument name="identityAttributeName">
          <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
        </Argument>
        <Argument name="identityAttributeValue">
          <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>  
import java.util.ArrayList;
import java.util.List;
import com.twilio.rest.api.v2010.Account;
import sailpoint.api.SailPointContext;
import sailpoint.object.Custom;
import sailpoint.tools.CloseableIterator;
import sailpoint.object.*;
  
  System.out.println("Task7 Correlated rule");   

		//String CreatedUser =  identity.getName();
		String CorrelatedUser =  account.getAttribute("Name");
		//String curDate = java.time.LocalDate.now().toString();
		
		String custobjName = "Created_Correlated_Users";
		Custom custlst = context.getObjectByName( Custom.class, custobjName);
		
		if(custlst != null)
		{
      System.out.println("The Custon object "+custobjName+"alredy exist");     

      if(custlst.getAttributes().get("Correlated Users")!=null)
      {
          List lstcorrelateduser = (List) custlst.getAttributes().get("Correlated Users");
          if(lstcorrelateduser.contains(CorrelatedUser)) 
          {
            System.out.println("The user "+CorrelatedUser+" alredy exist");    
          }
          else
          {
            lstcorrelateduser.add(CorrelatedUser);
          } 

          context.saveObject(custlst);
          context.commitTransaction();
      }
  			
		}
		else
		{  
      //Create custom object
      System.out.println("The Custon object creating");  
      Custom cust=new Custom();
      cust.setName(custobjName);
      Map m=new HashMap();
      
       ArrayList arCreatedUsers = new ArrayList();
       //arCreatedUsers.add(CreatedUser);
      
      ArrayList arcorrelatedusers = new ArrayList();
      arcorrelatedusers.add(CorrelatedUser);
      System.out.println("Adding values to Custon object");  
      
      m.put("Created Users", arCreatedUsers);     
      m.put("Correlated Users",arcorrelatedusers);  
      
      Attributes strb = new Attributes();
      strb.setMap(m);
      
      cust.setAttributes(strb);  
      
       context.saveObject(cust);
       context.commitTransaction();   
     
      System.out.println("The Custon object created"+cust.toXml());
    }</Source>
  </Rule>
  <Rule created="1664523631705" id="c0a8700183881e5c81838d56fc5503f8" language="beanshell" modified="1664530811922" name="Task7_CreationRule" type="IdentityCreation">
    <Description>Identity creation rules are used to set attributes on new Identity objects when they are created.  New identities may be created during the aggregation of application accounts, or optionally created after pass-through authentication.

One common operation is to change the name property of the identity when the default application name is complex (such as a directory DN).

Another common operation is to assign a set of initial capabilities based on the attributes pulled from the application account.</Description>
    <Signature returnType="void">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="environment" type="Map">
          <Description>
          Arguments passed to the aggregation task.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          Application being aggregated.
        </Description>
        </Argument>
        <Argument name="account" type="ResourceObject">
          <Description>
          The resource account for the identity being created.
        </Description>
        </Argument>
        <Argument name="identity" type="Identity">
          <Description>
          The identity that is being created.
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>import java.util.ArrayList;
import java.util.List;
import com.twilio.rest.api.v2010.Account;
import sailpoint.api.SailPointContext;
import sailpoint.object.Custom;
import sailpoint.tools.CloseableIterator;
import sailpoint.object.*;

		String CreatedUser = account.getAttribute("Name");
		//String CorrelatedUser =  "varshith";
		String curDate = java.time.LocalDate.now().toString();
		
		String custobjName = "Created_Correlated_Users";
		Custom custlst = context.getObjectByName( Custom.class, custobjName);
    System.out.println("Task 7 Rule");
		
		if(custlst != null)
		{
      System.out.println("The Custon object "+custobjName+"alredy exist");

      if(custlst.getAttributes().get("Created Users")!=null)
      {
          List lstcreateduser = (List) custlst.getAttributes().get("Created Users");
          if(lstcreateduser.contains(CreatedUser)) 
          {
            System.out.println("The user "+CreatedUser+" alredy exist");    
          }
          else
          {
            lstcreateduser.add(CreatedUser);
          }
          context.saveObject(custlst);
          context.commitTransaction();
      }  			
		}
		else
		{  
      //Create custom object
      System.out.println("The Custon object creating");  
      Custom cust=new Custom();
      cust.setName(custobjName);
      Map m=new HashMap();
      
       ArrayList arCreatedUsers = new ArrayList();
       arCreatedUsers.add(CreatedUser);
      
      ArrayList arcorrelatedusers = new ArrayList();
      //arcorrelatedusers.add(CorrelatedUser);
      System.out.println("Adding values to Custon object");  
      
      m.put("Created Users", arCreatedUsers);     
      m.put("Correlated Users",arcorrelatedusers);  
      
      Attributes strb = new Attributes();
      strb.setMap(m);
      
      cust.setAttributes(strb);  
      
       context.saveObject(cust);
       context.commitTransaction();   
     
      System.out.println("The Custon object created"+cust.toXml());
    }</Source>
  </Rule>
  <Rule created="1664798738977" id="c0a8700183881e5c81839dbcca210577" language="beanshell" modified="1665379299331" name="TASK8-CreatecustobjforEntNameDesc" type="Validation">
    <Description>Description.</Description>
    <Source>  
import java.util.ArrayList;
import java.util.List;
import sailpoint.object.Custom;
import sailpoint.object.*;
import java.util.HashMap;
import sailpoint.api.*;
  import java.util.*;
  
  QueryOptions qo = new QueryOptions();

List list = new ArrayList();
list.add(Filter.eq("application.name", "Delimited_HR_Application"));
Filter f = Filter.and(list);

qo.addFilter(f);
  
 List li2 = context.getObjects(ManagedAttribute.class, qo);
  //return li2;
    String custobjName = "EntitlementList";
		Custom custlst = context.getObjectByName( Custom.class, custobjName);
    System.out.println("Task 8 Rule");
		
	
			System.out.println("The Custon object "+custobjName+"alredy exist");
    }	if(custlst != null)
		{
   else
   {
      Custom cust=new Custom();
      cust.setName(custobjName);
      Map m=new HashMap();
      
      for( ManagedAttribute matb:li2)
      {
        if(matb.getDescriptions().get("en_US") != null)
        {
          m.put(matb.getValue(), matb.getDescriptions().get("en_US"));      
        }
      }
                        
      Attributes strb = new Attributes();
      strb.setMap(m);      
      cust.setAttributes(strb);  
      
       context.saveObject(cust);
       context.commitTransaction();   
     
     return cust;
       
     
   }
  
  
  
  
  </Source>
  </Rule>
  <Rule created="1665491390250" id="c0a8700183c6168d8183c705cf2a00d7" language="beanshell" modified="1665492281389" name="Task9_grpagr_jdbc" type="GroupAggregationRefresh">
    <Description>This rule is used to set the owner or modify the account group before it is persisted to the database.</Description>
    <Signature returnType="Object">
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="environment" type="Map">
          <Description>
          Arguments passed to the aggregation task.
        </Description>
        </Argument>
        <Argument name="obj" type="ResourceObject">
          <Description>
          A sailpoint.object.ResourceObject generated from the application
          and the ProvisioningPlan's ObjectRequest.
        </Description>
        </Argument>
        <Argument name="accountGroup" type="ManagedAttribute">
          <Description>
          The account group being refreshed.
        </Description>
        </Argument>
        <Argument name="groupApplication" type="Application">
          <Description>
          Application being aggregated.
        </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name="accountGroup" type="ManagedAttribute">
          <Description>
          The refreshed account group object.
        </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>import java.util.*;

Map m= new HashMap();
m.put("en_US","JDBC Ent Description");
System.out.println("accountGroup::"+accountGroup);
accountGroup.setDescriptions(m);

return accountGroup;</Source>
  </Rule>
  <Rule created="1665564642268" id="c0a8700183c6168d8183cb638bdb02c2" language="beanshell" modified="1665654440777" name="JDBC_BeforeProvision" type="BeforeProvisioning">
    <Description>An IdentityIQ server-side rule that is executed before the connector's provisioning method is called. This gives the customer the ability to customize or react to anything in the ProvisioningPlan BEFORE it is sent to the underlying connectors used in provisioning. 

This rule will be called for any application found in a plan that also has a configured 'beforeProvisioningRule' configured.  

The plan can be updated directly in the rule by reference and does not need to return the plan.</Description>
    <Signature>
      <Inputs>
        <Argument name="log">
          <Description>
          The log object associated with the SailPointContext.
        </Description>
        </Argument>
        <Argument name="context">
          <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
        </Argument>
        <Argument name="plan">
          <Description>
          The ProvisioningPlan object on its way to the Connector.
        </Description>
        </Argument>
        <Argument name="application">
          <Description>
          The application object that references this before/after script.
        </Description>
        </Argument>
      </Inputs>
    </Signature>
    <Source>
  import java.util.*;
  import sailpoint.object.*;
  import sailpoint.object.ProvisioningPlan.AccountRequest;
  import sailpoint.object.ProvisioningPlan.AttributeRequest;
  import sailpoint.object.ProvisioningPlan.Operation;

  if(plan!=null)
  {
       
   System.out.println("Prvision Plan without provision polocy Form:::"+plan.toXml());
    
    List accounts = plan.getAccountRequests();
    if ( ( accounts != null ) &amp;&amp; ( accounts.size() > 0 ) ) {
      for ( AccountRequest account : accounts ) {
       System.out.println("3");
          if ( AccountRequest.Operation.Create.equals( account.getOperation() ) ) { 
              System.out.println("1");
		String user = plan.getNativeIdentity();	
                  System.out.println("2");
		Identity id =context.getObjectByName(Identity.class, user);
                  System.out.println("3");
		account.add(new AttributeRequest("Name", id.getName()));		
    account.add(new AttributeRequest("FirstName", id.getFirstname()));		
    account.add(new AttributeRequest("LastName", id.getLastname()));	
    account.add(new AttributeRequest("EmailAddress", id.getEmail()));	
    account.add(new AttributeRequest("NetworkID", id.getAttribute("NetworkID")));	
          }   }}}
  
System.out.println("Prvision Plan after update plan with ide tity attrib data  :::"+plan.toXml());</Source>
  </Rule>
</sailpoint>
